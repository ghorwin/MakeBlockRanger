<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<meta name="author" content="Andreas Nicolai">
<title>Makeblock mBot Ranger: Eine Anleitung zur Programmierung des Roboterbausatzes mit der ArduinoIDE</title>
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */

@import url(../css/asciidoctor.css); /* Default asciidoc style framework - important */

/* roboto-condensed-regular - latin */
@font-face {
  font-family: 'Roboto Condensed';
  font-style: normal;
  font-weight: 400;
  src: url('../fonts/roboto-condensed-v25-latin-regular.eot'); /* IE9 Compat Modes */
  src: local(''),
       url('../fonts/roboto-condensed-v25-latin-regular.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('../fonts/roboto-condensed-v25-latin-regular.woff2') format('woff2'), /* Super Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-regular.woff') format('woff'), /* Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-regular.ttf') format('truetype'), /* Safari, Android, iOS */
       url('../fonts/roboto-condensed-v25-latin-regular.svg#RobotoCondensed') format('svg'); /* Legacy iOS */
}
/* roboto-condensed-italic - latin */
@font-face {
  font-family: 'Roboto Condensed';
  font-style: italic;
  font-weight: 400;
  src: url('../fonts/roboto-condensed-v25-latin-italic.eot'); /* IE9 Compat Modes */
  src: local(''),
       url('../fonts/roboto-condensed-v25-latin-italic.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('../fonts/roboto-condensed-v25-latin-italic.woff2') format('woff2'), /* Super Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-italic.woff') format('woff'), /* Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-italic.ttf') format('truetype'), /* Safari, Android, iOS */
       url('../fonts/roboto-condensed-v25-latin-italic.svg#RobotoCondensed') format('svg'); /* Legacy iOS */
}
/* roboto-condensed-700 - latin */
@font-face {
  font-family: 'Roboto Condensed';
  font-style: normal;
  font-weight: 700;
  src: url('../fonts/roboto-condensed-v25-latin-700.eot'); /* IE9 Compat Modes */
  src: local(''),
       url('../fonts/roboto-condensed-v25-latin-700.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('../fonts/roboto-condensed-v25-latin-700.woff2') format('woff2'), /* Super Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-700.woff') format('woff'), /* Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-700.ttf') format('truetype'), /* Safari, Android, iOS */
       url('../fonts/roboto-condensed-v25-latin-700.svg#RobotoCondensed') format('svg'); /* Legacy iOS */
}
/* roboto-condensed-700italic - latin */
@font-face {
  font-family: 'Roboto Condensed';
  font-style: italic;
  font-weight: 700;
  src: url('../fonts/roboto-condensed-v25-latin-700italic.eot'); /* IE9 Compat Modes */
  src: local(''),
       url('../fonts/roboto-condensed-v25-latin-700italic.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('../fonts/roboto-condensed-v25-latin-700italic.woff2') format('woff2'), /* Super Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-700italic.woff') format('woff'), /* Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-700italic.ttf') format('truetype'), /* Safari, Android, iOS */
       url('../fonts/roboto-condensed-v25-latin-700italic.svg#RobotoCondensed') format('svg'); /* Legacy iOS */
}

/* CUSTOMISATIONS */
/* Change the values in root for quick customisation. If you want even more fine grain... venture further. */

:root{
--maincolor:#FFFFFF;
--primarycolor:#a90e22;
--secondarycolor:#9f1d0b;
--tertiarycolor: #ededed;
--sidebarbackground:#CCC;
--linkcolor:#b71c1c;
--linkcoloralternate:#f44336;
--white:#FFFFFF;
--black:#000000;
}

/* Text styles */
body{font-family: "Roboto Condensed",sans-serif;}

h1,h2{color:var(--primarycolor) !important;font-family:"Roboto Condensed",sans-serif;}
h3,h4,h5,h6{color:var(--secondarycolor);font-family: "Roboto Condensed",sans-serif; }
.title{color:(--primarycolor) !important;font-family:"Roboto Condensed",sans-serif;font-style: normal; font-weight: normal;}
p{font-family: "Roboto Condensed",sans-serif ! important}
#toc.toc2 a{font-family:"Roboto Condensed",sans-serif;}
/*#toc.toc2 a:link{color:(--linkcolor) !important}
a:visited {color: #ffdbad;}
a.bare:visited {color: #204f83;}
a:hover {color: #317ed4;}
#toc.toc2 a:hover {color: #f1b464;}*/
/* code{background-color: var(--secondarycolor) !important;color:var(--white)} */
code,kbd,pre,samp{font-family:"Consolas","Droid Sans Mono","DejaVu Sans Mono",monospace;monospace;font-size:1em}

/* Table styles */
th{background-color: var(--tertiarycolor);color:var(--black) !important;}

#toctitle{color:var(--primarycolor);font-family: "Roboto Condensed",sans-serif;font-size: 1.6875em;}
#toc.toc2{background-color:#f4f8fd;}
/*#toc.toc2{background-color:#2C001E;color:white;}
#toc.toc2.a{color:white;}
*/

/* Responsiveness fixes */
video {
  max-width: 100%;
}

@media all and (max-width: 600px) {
table {
  width: 55vw!important;
  font-size: 3vw;
}

</style>
<link rel="stylesheet" href="../css/font-awesome.css">
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sa {
  color: #000000;
  font-weight: bold;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Makeblock mBot Ranger: Eine Anleitung zur Programmierung des Roboterbausatzes mit der ArduinoIDE</h1>
<div class="details">
<span id="author" class="author">Andreas Nicolai</span><br>
<span id="email" class="email"><a href="mailto:andreas.nicolai@gmx.net">andreas.nicolai@gmx.net</a></span><br>
<span id="revnumber">version 1.0 (17.02.2025)</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Inhaltsverzeichnis</div>
<ul class="sectlevel1">
<li><a href="#_einleitung">1. Einleitung</a>
<ul class="sectlevel2">
<li><a href="#_überblick_über_den_roboterbausatz">1.1. Überblick über den Roboterbausatz</a></li>
<li><a href="#_informationsquellen">1.2. Informationsquellen</a></li>
</ul>
</li>
<li><a href="#chap:install">2. Treiberinstallation und -konfiguration</a>
<ul class="sectlevel2">
<li><a href="#_linux">2.1. Linux</a>
<ul class="sectlevel3">
<li><a href="#sec:connecting_auriga">2.1.1. Verbindung des Auriga-Boards mit den Linux-PC</a></li>
<li><a href="#_behebung_von_brttly_problemen">2.1.2. Behebung von brttly Problemen</a></li>
</ul>
</li>
<li><a href="#_windows">2.2. Windows</a></li>
<li><a href="#_macos">2.3. MacOS</a></li>
</ul>
</li>
<li><a href="#_aufspielenaktualisieren_der_firmware_und_ein_erstes_testprogramm">3. Aufspielen/Aktualisieren der Firmware und ein erstes Testprogramm</a>
<ul class="sectlevel2">
<li><a href="#_firmware_update_neu_installieren">3.1. Firmware-Update / Neu-Installieren</a>
<ul class="sectlevel3">
<li><a href="#_firmware_mit_mblock_aktualisierenzurücksetzen">3.1.1. Firmware mit mBlock aktualisieren/zurücksetzen</a></li>
</ul>
</li>
<li><a href="#_makeblock_libraries_über_arduino_ide_bibliotheksverwaltung_installieren">3.2. Makeblock-Libraries über Arduino-IDE Bibliotheksverwaltung installieren</a>
<ul class="sectlevel3">
<li><a href="#_installation_via_bibliotheksmanager_empfohlen">3.2.1. Installation via Bibliotheksmanager (empfohlen)</a></li>
<li><a href="#_manuelle_installation">3.2.2. Manuelle Installation</a></li>
</ul>
</li>
<li><a href="#_software_erstellen_und_hochladen">3.3. Software erstellen und Hochladen</a></li>
<li><a href="#_firmware_update_installieren_zurücksetzen">3.4. Firmware Update installieren / zurücksetzen</a></li>
<li><a href="#_ein_erstes_testprogramm">3.5. Ein erstes Testprogramm</a></li>
</ul>
</li>
<li><a href="#chap:basics">4. Auriga-Pin/Ports Referenz</a>
<ul class="sectlevel2">
<li><a href="#_ports_und_zugeordnete_arduino_pins">4.1. Ports und zugeordnete Arduino-Pins</a></li>
<li><a href="#_weitere_verwendete_pins_des_mega_2560_prozessors">4.2. Weitere verwendete Pins des Mega 2560 Prozessors</a></li>
</ul>
</li>
<li><a href="#chap:LEDs">5. OnBoard LEDs und RGB Ring</a>
<ul class="sectlevel2">
<li><a href="#_allgemeines">5.1. Allgemeines</a></li>
<li><a href="#_standard_built_in_led">5.2. Standard built-in LED</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm">5.2.1. Beispielprogramm</a></li>
</ul>
</li>
<li><a href="#_onboard_leds_kommunikationsmodul">5.3. OnBoard LEDs (Kommunikationsmodul)</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm_2">5.3.1. Beispielprogramm</a></li>
</ul>
</li>
<li><a href="#_12er_rgb_led_ring">5.4. 12er RGB LED Ring</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm_3">5.4.1. Beispielprogramm</a></li>
<li><a href="#_die_wichtigsten_funktionen_der_mergbled_klasse">5.4.2. Die wichtigsten Funktionen der MeRGBLed Klasse</a></li>
<li><a href="#_programmierideen">5.4.3. Programmierideen</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_onboard_sensoren_licht_schall_temperature_gyroskop">6. OnBoard Sensoren (Licht, Schall, Temperature, Gyroskop)</a>
<ul class="sectlevel2">
<li><a href="#_lautstärkeschall">6.1. Lautstärke/Schall</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm_4">6.1.1. Beispielprogramm</a></li>
</ul>
</li>
<li><a href="#_lichthelligkeit">6.2. Licht/Helligkeit</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm_5">6.2.1. Beispielprogramm</a></li>
</ul>
</li>
<li><a href="#_temperatur">6.3. Temperatur</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm_6">6.3.1. Beispielprogramm</a></li>
</ul>
</li>
<li><a href="#_gyroskop">6.4. Gyroskop</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm_7">6.4.1. Beispielprogramm</a></li>
</ul>
</li>
<li><a href="#_programmierideen_2">6.5. Programmierideen</a></li>
</ul>
</li>
<li><a href="#_töne_mit_dem_passiven_buzzer_auf_dem_board">7. Töne mit dem passiven Buzzer auf dem Board</a>
<ul class="sectlevel2">
<li><a href="#_allgemeines_2">7.1. Allgemeines</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm_8">7.1.1. Beispielprogramm</a></li>
</ul>
</li>
<li><a href="#_verwendung_der_makeblock_klasse_mebuzzer">7.2. Verwendung der Makeblock Klasse MeBuzzer</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm_9">7.2.1. Beispielprogramm</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chap:motors">8. Motorsteuerung</a>
<ul class="sectlevel2">
<li><a href="#_allgemeines_3">8.1. Allgemeines</a></li>
<li><a href="#_direkte_ansteuerung_über_pwm_und_digitale_pins">8.2. Direkte Ansteuerung über PWM und digitale Pins</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm_direkte_ansteuerung">8.2.1. Beispielprogramm - Direkte Ansteuerung</a></li>
</ul>
</li>
<li><a href="#_ansteuerung_über_encoder_klasse_der_bibliothek">8.3. Ansteuerung über Encoder-Klasse der Bibliothek</a>
<ul class="sectlevel3">
<li><a href="#sec:motor:encodertest">8.3.1. Beispielprogramm - Ansteuerung mittels Bibliotheksfunktion</a></li>
<li><a href="#_interrupts_für_encoder_signale">8.3.2. Interrupts für Encoder-Signale</a></li>
<li><a href="#_testlauf_und_geschwindigkeitsmessung_mit_und_ohne_kette">8.3.3. Testlauf und Geschwindigkeitsmessung mit und ohne Kette</a></li>
</ul>
</li>
<li><a href="#_motorleistung_adaptiv_regeln_mittels_in_der_encoder_klasse">8.4. Motorleistung adaptiv regeln mittels in der Encoder-Klasse</a></li>
<li><a href="#_programmierung_des_rangers_ohne_makeblock_bibliothek_mit_robuster_entfernungsmessung">8.5. Programmierung des Rangers OHNE Makeblock-Bibliothek mit robuster Entfernungsmessung</a></li>
</ul>
</li>
<li><a href="#_abschließende_bemerkungen">9. Abschließende Bemerkungen</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_einleitung">1. Einleitung</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Der <em>MakeBlock Ranger</em> Bausatz ist ziemlich cool und bietet einiges. Leider ist eigentlich nur die Block-basierte Programmierung wirklich gut dokumentiert, aber diese hat Grenzen. Dokumentation für die Programmierung mittels C in der Arduino IDE gibt es kaum, zumindest keine offizielle, daher habe ich dieses Tutorial und Anleitung zusammengestellt. Außerdem soll diese Dokumentation als Leitfaden für einen Programmier-/Robotikkurs an der Schule dienen.</p>
</div>
<div class="paragraph">
<p>Diese <em>Makeblock Ranger</em> Anleitung baut auf vorhandenen Grundlagen zur Arduino-Programmierung auf. Man sollte also schon die Arduino IDE kennen und natürlich auch Grundlagen der C-Programmiersprache beherrschen. In diesem Tutorial bzw. Robotik-Kurs wird gezeigt, wie man den mBot Ranger Bausatz mittels der Arduino-IDE und der C bzw. C++ Programmiersprache programmiert (wenn man also die Stufe der Block-Programmierung überwunden hat).</p>
</div>
<div class="paragraph">
<p>Es geht also um folgenden Robotor</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/makeblock-mbot-ranger.jpg" alt="makeblock mbot ranger" width="400">
</div>
</div>
<div class="paragraph">
<p>bzw. die darin verbaute Auriga-Platine mit dem ATmega-Prozessor (wie auf einem Arduino Board)</p>
</div>
<div class="sect2">
<h3 id="_überblick_über_den_roboterbausatz">1.1. Überblick über den Roboterbausatz</h3>
<div class="paragraph">
<p>Als Roboterbausatz wird der Makeblock mBot Ranger verwendet. Es gibt noch andere Makeblock Bausätze. Die Pin/Port-Belegung ist dann etwas anders und es gibt andere Sensoren, aber im Großen und Ganzen funktioniert das alles sehr ähnlich wie bei dem hier beschriebenen mBot Ranger.</p>
</div>
<div class="paragraph">
<p>Mit dem Bausatz lassen sich 3 verschiedene Modelle bauen (und mit etwas Kreativität noch weitere):</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/makeblock-mbot-ranger.jpg" alt="makeblock mbot ranger" width="300">
</div>
<div class="title">Abbildung 1. Land Raider - ein Kettenfahrzeug mit Linienfolgesensor und Abstandsradar</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/makeblock-mbot-raptor.jpg" alt="makeblock mbot raptor" width="300">
</div>
<div class="title">Abbildung 2. Dashing Raptor - ähnlich wie Ranger - ohne Ketten zwar weniger cool, dafür schneller unterwegs (auf glatten Fußböden)</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/makeblock-mbot-bird.jpg" alt="makeblock mbot bird" width="300">
</div>
<div class="title">Abbildung 3. Nervous Bird - interessante Demo für die Verwendung des Neigungs-/Beschleunigungssensors (quasi ein Segway-Personal-Transporter ohne Person); mit diesem Modell kann man seine ganze Kreativität bei der Regelungsprogrammierung ausspielen, um das Gefährt auf hügeligem Gelände sicher und mit konstanter Geschwindigkeit fahren zu lassen.</div>
</div>
<div class="paragraph">
<p>Der <em>MakeBlock Ranger</em> Bausatz verwendet ein <em>Auriga Board</em> mit einem <em>ATmega2560</em> Prozessor, wie auf dem <em>Arduino Mega 2560</em> Board (damit ist die Programmierung schon sehr ähnlich der <em>Arduino</em>-Programmierung). Das Auriga-Board ist die Weiterentwicklung des Orion-Boards (welches bei früheren mBot Bausätzen verwendet wurde) und kann einiges mehr.</p>
</div>
<div class="paragraph">
<p>Hier ist eine Funktions-/Ausstattungsbeschreibung (basierend auf der Produktbeschreibung aus
<a href="https://shop.technik-lpe.de/steuerboards/872-auriga-steuerboard-6928819504967.html">shop.technik-lpe.de</a>:</p>
</div>
<div class="paragraph">
<p>Der <strong>Auriga</strong> ist eine gut ausgestattete Hauptsteuerplatine, die speziell für den MINT-Unterricht entwickelt wurde. Basierend auf dem ATmega 2560 sind auf dem Auriga bereits eine Reihe von Sensoren und Aktoren vebaut, und es können externe Sensoren oder Motoren angesteckt werden. Hier ist ein kleiner Überblick:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Onboard-Gyroskop, Tonsensor, passiver Summer und Temperatursensor, 2 Lichtsensoren</p>
</li>
<li>
<p>Unterstützt DC-Motoren, Schrittmotoren, Servoregler, Smart Servos, Encoder-Motoren, etc.</p>
</li>
<li>
<p>Kann zwei Encoder-Motoren ansteuern und unterstützt Überstromschutz für 4A (sofort).</p>
</li>
<li>
<p>Unterstützt Bluetooth und drahtlose Bluetooth-Upgrade-Firmware Bluetooth-Dongle</p>
</li>
<li>
<p>Blaue LED</p>
</li>
<li>
<p>WS1282 RGB LED ring</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/auriga_schaubild.jpg" alt="auriga schaubild" width="500">
</div>
<div class="title">Abbildung 4. Schaubild der Aurigaplatine mit verbauten Sensoren</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/farbcodierung_auriga.jpg" alt="farbcodierung auriga" width="150">
</div>
<div class="title">Abbildung 5. Farbkodierung der Anschlüsse (Details dazu im Kapitel zu den RJ25 Ports)</div>
</div>
<div class="ulist">
<ul>
<li>
<p>PORT1 - PORT4 unterstützen einen kontinuierlichen 3,5A-Ausgang (max. 5A)</p>
</li>
<li>
<p>PORT5 - PORT10 haben einen Kurzschluss- und Überstromschutz für 3A</p>
</li>
<li>
<p>PORT5 - PORT10 unterstützen kontinuierlich 5V DC und 4A Ausgang (max. 3A)</p>
</li>
<li>
<p>PORT1 - PORT4 haben einen Kurzschluss- und Überstromschutz für 3,5A</p>
</li>
<li>
<p>USB-Anschluss mit antistatischem Schutz (Akkus werden darüber nicht geladen)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_informationsquellen">1.2. Informationsquellen</h3>
<div class="paragraph">
<p>Die offizielle Dokumentation des Roboterbausatzes schweigt sich über die Internas und Programmierung der Platine ziemlich aus. Daher basiert diese Anleitung auf Reverse-Engineering, Literaturrecherche im Internet und Sichtung vieler Forenbeiträge.</p>
</div>
<div class="paragraph">
<p>Viele nachfolgend und in den anderen Teilen beschriebene Details habe ich aus dem englischsprachigen Text von <em>Gosse Adema</em> (<a href="https://www.instructables.com/Advanced-Makeblock-Sensors-DIY">https://www.instructables.com/Advanced-Makeblock-Sensors-DIY</a>) gefunden.</p>
</div>
<div class="paragraph">
<p>Hier sind noch einige Dokumente, die ich zusammengetragen habe:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="../downloads/Makeblock_Leaflet_mBot-Ranger_2018Q3_V1-1-1_View.pdf">MakeBlock Ranger Flyer</a></p>
</li>
<li>
<p><a href="../downloads/mBot-Ranger_Blue_Instruction_Book.pdf">mBot Ranger (Bau-)Anleitung</a> - enthält auch einen guten Kurzüberblick über die Lage der oben aufgelisteten OnBoard-Sensoren</p>
</li>
<li>
<p><a href="../downloads/getting_started_with_mBlock.pdf">mBlock Entwicklungsumgebung - Getting Started</a></p>
</li>
<li>
<p><a href="../downloads/MeAuriga_Schaltplan.pdf">Auriga Schaltplan</a></p>
</li>
<li>
<p><a href="../downloads/MeAuriga_Pinout.pdf">Auriga Pinout</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Auch gibt es zahlreiche Github-Projekte (siehe Schlagwort <a href="https://github.com/topics/makeblock">MakeBlock</a> ).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap:install">2. Treiberinstallation und -konfiguration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Bevor man den Roboter bzw. die Auriga-Platine programmieren kann, muss man erstmal das jeweilige Betriebssystem vorbereiten. Für Windows, Linux und MacOS gibt es hier jeweils unterschiedliche Vorgehensweisen.</p>
</div>
<div class="sect2">
<h3 id="_linux">2.1. Linux</h3>
<div class="paragraph">
<p>Nachfolgende Schritte sind für ein hinreichend aktuelles Linux beschrieben, konkret Ubuntu 22.04 oder neuer. Eigentlich müsste das Board aber auch mit älteren Systemen wie Ubuntu 18.04 oder so noch problemlos funktionieren.</p>
</div>
<div class="sect3">
<h4 id="sec:connecting_auriga">2.1.1. Verbindung des Auriga-Boards mit den Linux-PC</h4>
<div class="paragraph">
<p>Der erste Schritt zur Programmierung des Auriga Boards ist es, eine serielle Verbindung mit dem Board aufzubauen. Dazu verbindet man das Board via USB-Kabel mit dem PC.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wie üblich unter Linux muss der Nutzer zum Zugriff auf COM Ports der Gruppe <em>dialout</em> zugehören.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>sudo dmesg</code> sollte dann ausgeben, mit welchem COM-Port das Bord verbunden ist.</p>
</div>
<div class="listingblock">
<div class="title">Ausgabe von dmesg beim Anstecken des Auriga Boards</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="o">&gt;</span> <span class="nb">sudo </span>dmesg
<span class="o">[</span> 1588.506008] usb 3-2: new full-speed USB device number 4 using xhci_hcd
<span class="o">[</span> 1588.677924] usb 3-2: New USB device found, <span class="nv">idVendor</span><span class="o">=</span>1a86, <span class="nv">idProduct</span><span class="o">=</span>7523, <span class="nv">bcdDevice</span><span class="o">=</span> 2.64
<span class="o">[</span> 1588.677942] usb 3-2: New USB device strings: <span class="nv">Mfr</span><span class="o">=</span>0, <span class="nv">Product</span><span class="o">=</span>2, <span class="nv">SerialNumber</span><span class="o">=</span>0
<span class="o">[</span> 1588.677949] usb 3-2: Product: USB Serial
<span class="o">[</span> 1588.686988] ch341 3-2:1.0: ch341-uart converter detected
<span class="o">[</span> 1588.701256] usb 3-2: ch341-uart converter now attached to ttyUSB0</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_behebung_von_brttly_problemen">2.1.2. Behebung von brttly Problemen</h4>
<div class="paragraph">
<p>Bei Ubuntu 22.04 und einigen neueren Ubuntu Versionen wird beim Anschließen des Boards an den USB-Port die Verbindung mit <code>/dev/ttyUSB0</code> kurz hergestellt und gleich wieder unterbrochen</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Ab Ubuntu 24.04 scheint das aber kein Problem mehr zu sein.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ausgabe von <code>sudo dmesg</code> ist ähnlich wie:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>[  284.973894] usb 3-4.2: ch34x converter now attached to ttyUSB0
[  285.019333] usb 3-4.2: usbfs: interface 0 claimed by ch34x while 'brltty' sets config #1
[  285.019883] ch34x ttyUSB0: ch34x converter now disconnected from ttyUSB0
[  285.019895] ch34x 3-4.2:1.0: device disconnected</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das Problem liegt daran, dass der <code>brltty</code>-Dienst (braille display driver/Treiber für ein <a href="https://de.wikipedia.org/wiki/Braillezeile">Brailledisplay</a>) dazwischenfunkt.</p>
</div>
<div class="paragraph">
<p>Den brltty Dienst (Assistenzdienst) schaltet man wie folgt ab:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code># Systemdienste deaktivieren
sudo systemctl mask brltty.path
sudo systemctl mask brltty.service

# udev Regeln ausschalten
for f in /usr/lib/udev/rules.d/*brltty*.rules; do
    sudo ln -s /dev/null "/etc/udev/rules.d/$(basename "$f")"
done
# Dienste neu laden
sudo udevadm control --reload-rules</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nun kann man das Board verbinden und sollte die Ausgabe wie oben in <a href="#sec:connecting_auriga">Abschnitt 2.1.1</a> sehen.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_windows">2.2. Windows</h3>
<div class="ulist">
<ul>
<li>
<p>TODO: ch341 Treiber&#8230;&#8203;</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_macos">2.3. MacOS</h3>
<div class="ulist">
<ul>
<li>
<p>TODO: Intel CPUs ch341 Treiber</p>
</li>
<li>
<p>TODO: M CPUs</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_aufspielenaktualisieren_der_firmware_und_ein_erstes_testprogramm">3. Aufspielen/Aktualisieren der Firmware und ein erstes Testprogramm</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_firmware_update_neu_installieren">3.1. Firmware-Update / Neu-Installieren</h3>
<div class="paragraph">
<p>Der <em>Makeblock Ranger</em> bzw. das Board und der Prozessor werden mit einer vorinstallierten <em>Firmware</em> geliefert. Diese Firmware ist nichts anderes als ein (recht komplexes) Arduino-Programm. Dieses Programm enthält die Basisfunktionalität (wie im Handbuch beschrieben), einschließlich der Bluetooth-Kommunikation mit der SmartPhone-App.</p>
</div>
<div class="paragraph">
<p>Dieses Programm (also die <em>Firmware</em>) ist im Quelltext verfügbar. Den kann man sich herunterladen (siehe unten) und nach Belieben anpassen und verändern. Das ist auch einer der Gründe, warum ich die MakeBlock Roboterbausätze ziemlich cool finde.  Außerdem kann man in der Firmware jede Menge abgucken.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wenn man nach dem Hochladen eigener Programme mal wieder die Originalfunktionalität haben will, spielt man einfach dieses Firmware-Programm hoch und hat wieder den Auslieferungszustand. Man kann also nichts kaputt machen :-)</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die originale Firmware stellt auch die Funktionalität für die "Live"-Tests in der mBlock-Umgebung (z.B. zum Sensor-Auslesen) bereit. Sobald man ein anderes Programm hochgeladen hat, funktioniert diese "Live"-Funktionalität nicht mehr. Wenn man also wieder mit der Block-basierten Programmierung in mBlock arbeiten will und dort die "Live"-Test Funktionalität braucht, lädt man einfach die Firmware wieder hoch und mBlock funktioniert wieder wie bisher.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wie wir später sehen werden, kann man aber über den <em>Serial Monitor</em> der Arduino-IDE alle Sensorwerte bequem ausgeben und braucht die mBlock Oberfläche gar nicht mehr.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_firmware_mit_mblock_aktualisierenzurücksetzen">3.1.1. Firmware mit mBlock aktualisieren/zurücksetzen</h4>
<div class="paragraph">
<p>Die Firmware kann auch mit der mBlock Entwicklungsumgebung installiert werden.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In der aktuellen mBlock Webversion scheint der Download der Firmware allerdings nicht mehr robust zu funktionieren. Auch funktionieren die Treiber für Linux nicht mehr und auch sonst scheint die Software nicht (mehr) richtig zu funktionieren. Außerdem ist die original-Firmware seit 2020 nicht mehr weiterentwickelt worden. Daher sollte die Firmware besser wie nachfolgend beschrieben mit der Arduino-IDE aktualisiert werden.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_makeblock_libraries_über_arduino_ide_bibliotheksverwaltung_installieren">3.2. Makeblock-Libraries über Arduino-IDE Bibliotheksverwaltung installieren</h3>
<div class="paragraph">
<p>Für das Compilieren der Firmware sind aber noch die Makeblock-Bibliotheken notwendig. Dafür gibt es zwei Methoden:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Installation mittels Arduino-IDE Bibliotheksverwaltung (empfohlen!)</p>
</li>
<li>
<p>Manuelle Installation der Bibliothek, oder</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_installation_via_bibliotheksmanager_empfohlen">3.2.1. Installation via Bibliotheksmanager (empfohlen)</h4>
<div class="paragraph">
<p>Die Installation der makeblock-Bibliothek erfolgt analog zu anderen Arduino-Bibliotheken.</p>
</div>
<div class="paragraph">
<p>Abgesehen von der Original-Bibliothek gibt es inzwischen verschiedene Forks mit aktualisierten Quelltexten, die einige Fehler beheben. In der aktuellen Version der Arduino-IDE ist eine solche aktualisierte Version auch direkt über den Bibliotheksmanager verfügbar (Bibliotheksverwaltung öffnen und im Filter <em>makeblock</em> eingeben):</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/arduino-ide-makeblock-library-install.png" alt="arduino ide makeblock library install">
</div>
<div class="title">Abbildung 6. Bibliotheksmanager in der Arduino-IDE und ausgewählte MakeBlock Dive Updated Bibliothek</div>
</div>
</div>
<div class="sect3">
<h4 id="_manuelle_installation">3.2.2. Manuelle Installation</h4>
<div class="paragraph">
<p>Alternativ gibt es auch hier die Möglichkeit, die Bibliothek via Download des Quelltextes manuell zu installieren. Das ist vielleicht mal notwendig, wenn die Bibliothek nicht mehr vom Bibliotheksverwalter angeboten wird.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Man kann so auch aktualisierte Versionen einer Bibliothek installieren, ohne auf die offiziellen Bibliotheksquellen zu warten.
Außerdem kann man so eigene Anpassungen in der Bibliothek (so man das braucht) integrieren.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Dazu lädt man den Quelltext herunter, z.B. den  <a href="https://github.com/nbourre/Makeblock-Libraries">MakeBlock Drive Updated Quelltext</a>. Die heruntergeladene Bibliothek kann in der Arduino-IDE via <em>Sketch&#8594;Bibliothek einbinden&#8594;.ZIP-Bibliothek hinzufügen&#8230;&#8203;</em> eingebunden werden.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die offiziellen MakeBlock-Bibliotheken werden seit 2020 nicht mehr aktiv weiterentwickelt.</p>
</div>
<div class="paragraph">
<p>Falls man doch mal die Originalversionen braucht: Das offizielle <a href="https://github.com/Makeblock-official/Makeblock-Libraries.git">Makeblock-Libraries GitHub Repository</a> enthält die originalen Quelltexte. Man kann die Bibliothek auch über den Link über folgenden Link herunterladen: <a href="https://codeload.github.com/Makeblock-official/Makeblock-Libraries/zip/master">Makeblock-Libraries - ZIP</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_software_erstellen_und_hochladen">3.3. Software erstellen und Hochladen</h3>
<div class="paragraph">
<p>Wie üblich in der Arduino IDE wählt man zuerst</p>
</div>
</div>
<div class="sect2">
<h3 id="_firmware_update_installieren_zurücksetzen">3.4. Firmware Update installieren / zurücksetzen</h3>
<div class="paragraph">
<p>Die Makeblock Bibliothek bringt als Beispiel-Programm die <em>Firmware</em> mit. Man wählt diese über <em>Datei&#8594;Beispiele&#8594;MakeBlock Drive Updated&#8594;Firmware_For_Auriga</em> aus.</p>
</div>
<div class="paragraph">
<p>Man muss dann in der Arduino-IDE noch den Port und die CPU einstellen: hier wählt man <em>Arduino Mega or Mega 2560</em> aus (dazu gleich mehr im folgenden Kapitel). Dann kann man das Firmware-Programm übersetzen und hochladen. So kann man nach dem Ausprobieren eigener Programme stets zum Originalzustand zurückkehren.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ein_erstes_testprogramm">3.5. Ein erstes Testprogramm</h3>
<div class="paragraph">
<p>Um das Aufspielen des Programms zu testen, kann man die eingebaute LED auf Pin 13 (wie bei jedem Arduino Board) blinken lassen. Das Programm dazu entspricht dem typischen Arduino Blink-Beispielprogramm:</p>
</div>
<div class="listingblock">
<div class="title">Triviales Beispielprogramm für ein Arduino-Board. Die eingebaute LED wird ein- und ausgeschaltet. Um sie von der rhythmisch blinkenden anderen blauen LED zu unterscheiden, lassen wir sie lang-kurz blinken.</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Eingebaute LED auf dem Arduino-Board blinken lassen</span>
<span class="c1">// Dies ist quasi das Standard-Test-Programm für die meisten Arduino-Boards</span>

<span class="kt">int</span> <span class="n">BlueLed</span> <span class="o">=</span> <span class="n">LED_BUILTIN</span><span class="p">;</span> <span class="c1">// Pin 13</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pinMode</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// lang an</span>
  <span class="n">digitalWrite</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
  <span class="n">delay</span> <span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
  <span class="c1">// kurz aus</span>
  <span class="n">digitalWrite</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
  <span class="n">delay</span> <span class="p">(</span><span class="mi">500</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die LED ist etwas schwer zu erkennen und liegt einseitig etwas verdeckt. Sehr sinnvoll ist damit ihre Ansteuerung nicht, aber zum Testen kann man das ja mal machen.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="imageblock text-left">
<div class="content">
<img src="../images/auriga-Builtin-LED.gif" alt="auriga Builtin LED">
</div>
<div class="title">Abbildung 7. Auriga Built-in LED</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap:basics">4. Auriga-Pin/Ports Referenz</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Auf dem <em>Auriga</em>-Board ist ein ATmega2560 Prozessor verbaut wie auf dem Arduino Mega 2560 Board (<a href="../Atmel-2549-8-bit-AVR-Microcontroller-ATmega640-1280-1281-2560-2561_datasheet.pdf">Datenblatt</a> ). Dieser hat insgesamt 54 digitale Ein- und Ausgangspins, wovon 15 mittels PWM angesteuert werden können. Außerdem hat er noch 16 analoge Inputs und 4 UARTs. Das sollte doch für einen kleinen Roboter reichen. Für die Programmierung dieses Mikroprozessors muss man natürlich wissen, welche Pins davon wofür genutzt werden.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In diesem Kapitel wird ein Überblick über diese Pins und deren Verwendung gegeben. Die Informationen in diesem Kapitel sind als Referenz zu verstehen, da die einzelnen Ports und Pins in den nachfolgenden Kapiteln für alle Komponenten nochmal einzeln eingeführt und erklärt werden. Wer möchte, kann also gerne zum ersten echten Programmierkapitel (<a href="#chap:LEDs">Abschnitt 5</a>zum Thema <em>OnBoard LEDs und RGB Ring</em> ) vorspringen und einfach bei Bedarf hierher zurück kommen.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Einige der Ein- und Ausgänge sind direkt mit Komponenten auf dem Auriga-Board verbunden. Andere sind mit externen Ports und Anschlüssen verbunden. Die Details dazu findet man auf dem <a href="../downloads/MeAuriga_Schaltplan.pdf">Auriga Schaltplan</a>. Der ist allerdings nicht leicht zulesen und enthält auch viele Informationen, welche man bei Verwendung der MakeBlock-Programmierbibliothek gar nicht benötigt.</p>
</div>
<div class="paragraph">
<p>Daher ist es sinnvoller, sich das sogenannte Pinout-Diagramm anzuschauen.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/auriga_pinout.png" alt="auriga pinout">
</div>
<div class="title">Abbildung 8. Auriga Board PinOut Diagramm</div>
</div>
<div class="paragraph">
<p>Das Pinout-Diagramm gibt es auch als <a href="../downloads/MeAuriga_Pinout.pdf">Auriga Pinout PDF</a>.</p>
</div>
<div class="sect2">
<h3 id="_ports_und_zugeordnete_arduino_pins">4.1. Ports und zugeordnete Arduino-Pins</h3>
<div class="paragraph">
<p>Innerhalb der Makeblock-Bibliothek werden Sensoren und Aktoren über Ports angesprochen, statt direkt Pins zu bezeichnen. Dies liegt daran, dass die Makeblock-Bibliothek auch für andere mBot Modelle ähnlich verwendet wird. Die Zuordnung von Ports zu Pins ist in Quelltext-Header-Dateien hinterlegt, welche für die unterschiedlichen mBot-Bausätze anders heißen. Die für <em>Auriga</em>-Board verwendete Diese sind in der Makeblock-Bibliothek in der Datei <code>MeAuriga.h</code> definiert:</p>
</div>
<div class="listingblock">
<div class="title">Auszug aus der Header-Datei <em>MeAuriga.h</em></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">MePort_Sig</span> <span class="n">mePort</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">{</span> <span class="n">NC</span><span class="p">,</span> <span class="n">NC</span> <span class="p">},</span> <span class="p">{</span>   <span class="mi">5</span><span class="p">,</span>   <span class="mi">4</span> <span class="p">},</span> <span class="p">{</span>   <span class="mi">3</span><span class="p">,</span>   <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span>   <span class="mi">7</span><span class="p">,</span>   <span class="mi">6</span> <span class="p">},</span> <span class="p">{</span>   <span class="mi">9</span><span class="p">,</span>   <span class="mi">8</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span> <span class="p">},</span> <span class="p">{</span> <span class="n">A10</span><span class="p">,</span> <span class="n">A15</span> <span class="p">},</span> <span class="p">{</span>  <span class="n">A9</span><span class="p">,</span> <span class="n">A14</span> <span class="p">},</span> <span class="p">{</span>  <span class="n">A8</span><span class="p">,</span> <span class="n">A13</span> <span class="p">},</span> <span class="p">{</span>  <span class="n">A7</span><span class="p">,</span> <span class="n">A12</span> <span class="p">},</span>
	<span class="c1">//             LIGHT2        LIGHT1        TEMP          SOUND</span>
	<span class="p">{</span> <span class="n">A6</span><span class="p">,</span><span class="n">A11</span> <span class="p">},</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">A2</span> <span class="p">},</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">A3</span> <span class="p">},</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">A0</span> <span class="p">},</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">A1</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">NC</span><span class="p">,</span> <span class="n">NC</span> <span class="p">},</span> <span class="p">{</span> <span class="n">NC</span><span class="p">,</span> <span class="n">NC</span> <span class="p">},</span>
<span class="p">};</span>

<span class="c1">// etwas umformatiert und kommentiert</span>
<span class="n">MePort_Sig</span> <span class="n">mePort</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">Port</span> <span class="mi">0</span>  <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">NC</span> <span class="p">}</span>   <span class="n">Not</span> <span class="n">connected</span>
	<span class="n">Port</span> <span class="mi">1</span>  <span class="p">{</span>   <span class="mi">5</span><span class="p">,</span>   <span class="mi">4</span> <span class="p">}</span>   <span class="n">red</span>
	<span class="n">Port</span> <span class="mi">2</span>  <span class="p">{</span>   <span class="mi">3</span><span class="p">,</span>   <span class="mi">2</span> <span class="p">}</span>   <span class="n">red</span>
	<span class="n">Port</span> <span class="mi">3</span>  <span class="p">{</span>   <span class="mi">7</span><span class="p">,</span>   <span class="mi">6</span> <span class="p">}</span>   <span class="n">red</span>
	<span class="n">Port</span> <span class="mi">4</span>  <span class="p">{</span>   <span class="mi">9</span><span class="p">,</span>   <span class="mi">8</span> <span class="p">}</span>   <span class="n">red</span>
	<span class="n">Port</span> <span class="mi">5</span>  <span class="p">{</span>  <span class="mi">16</span><span class="p">,</span>  <span class="mi">17</span> <span class="p">}</span>   <span class="n">grey</span>
	<span class="n">Port</span> <span class="mi">6</span>  <span class="p">{</span> <span class="n">A10</span><span class="p">,</span> <span class="n">A15</span> <span class="p">}</span>   <span class="n">universal</span>
	<span class="n">Port</span> <span class="mi">7</span>  <span class="p">{</span>  <span class="n">A9</span><span class="p">,</span> <span class="n">A14</span> <span class="p">}</span>   <span class="n">universal</span>
	<span class="n">Port</span> <span class="mi">8</span>  <span class="p">{</span>  <span class="n">A8</span><span class="p">,</span> <span class="n">A13</span> <span class="p">}</span>   <span class="n">universal</span>
	<span class="n">Port</span> <span class="mi">9</span>  <span class="p">{</span>  <span class="n">A7</span><span class="p">,</span> <span class="n">A12</span> <span class="p">}</span>   <span class="n">universal</span>
	<span class="n">Port</span> <span class="mi">10</span> <span class="p">{</span>  <span class="n">A6</span><span class="p">,</span> <span class="n">A11</span> <span class="p">}</span>   <span class="n">universal</span>
	<span class="n">Port</span> <span class="mi">11</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">A2</span> <span class="p">}</span>   <span class="n">light</span> <span class="n">sensor</span> <span class="mi">1</span>
	<span class="n">Port</span> <span class="mi">12</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">A3</span> <span class="p">}</span>   <span class="n">light</span> <span class="n">sensor</span> <span class="mi">2</span>
	<span class="n">Port</span> <span class="mi">13</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">A0</span> <span class="p">}</span>   <span class="n">temperature</span> <span class="n">sensor</span>
	<span class="n">Port</span> <span class="mi">14</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">A1</span> <span class="p">}</span>   <span class="n">sound</span> <span class="n">sensor</span>
	<span class="n">Port</span> <span class="mi">15</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">NC</span> <span class="p">}</span>
	<span class="n">Port</span> <span class="mi">16</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">NC</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Jeder Makeblock-Port ist an 2 Pins angeschlossen. Diese Pins werden als <em>Slot1</em> und <em>Slot2</em> bezeichnet. <em>NC</em> steht für <em>Not Connected</em>. Ports 1 bis 10 sind RJ25 Ports (dazu mehr im Kapitel zu den RJ25 Anschlüssen <a href="#chap:rj25">[chap:rj25]</a>).</p>
</div>
<div class="paragraph">
<p>Als Beispiel: der Port 6 ist an den analogen Pin 10 und analogen Pin 15 des Mikrocontrollers angeschlossen.</p>
</div>
</div>
<div class="sect2">
<h3 id="_weitere_verwendete_pins_des_mega_2560_prozessors">4.2. Weitere verwendete Pins des Mega 2560 Prozessors</h3>
<div class="paragraph">
<p>Einige Komponenten sind direkt über IO Pins anzusteuern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>Pin 44 = 12 RGB LED Ring
Pin 45 = Buzzer
Pin 13 = Blaue LED (built-in LED)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Motoren können zwar recht einfach durch die Bibliothek angesteuert werden, hier sind aber nochmal die Pins (falls man die Motoren klassisch über Arduino Pin PWM-write-Befehle ansteuern möchte, siehe Kapitel über die Motorensteuerung <a href="#chap:motors">Abschnitt 8</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>ENA A  = pin 19
ENA B  = pin 42
PWMA   = pin 11
DIR A2 = pin 49
DIR A1 = pin 48

ENB A  = pin 18
ENB B  = pin 43
PWMB   = pin 10
DIR B1 = pin 47
DIR B2 = pin 46</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap:LEDs">5. OnBoard LEDs und RGB Ring</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Nun beginnen wir mit der Programmierung. Auf dem Auriga-Board sind zahlreiche LEDs verbaut. In diesem Kapitel geht es darum, diese LEDs zum Leuchte zu bringen.</p>
</div>
<div class="sect2">
<h3 id="_allgemeines">5.1. Allgemeines</h3>
<div class="paragraph">
<p>Auf dem Board gibt es eine ganze Reihe von LEDs, die man programmieren kann. Da ist zunächst eine blaue Standard Arduino LED, die wie bei anderen Arduino Boards auf dem Pin 13 anzusprechen ist. Dann sind da noch 2 LEDs beim Kommunikationsmodul vorhanden, die primär Kommunikation über die serielle Schnittstelle (Bluetooth/USB) anzeigen. Dazu gibt es noch den 12er RGB LED Ring, bei dem man alle 12 LED unterschiedlich bunt einfärben kann und damit ein vielseitiges Anzeigegerät für Roboterzustände hat.</p>
</div>
<div class="paragraph">
<p>Dann gibt es noch eine grüne "On"-Status-LED (nicht programmierbar, hart verdrahtet), 2 rote LEDs direkt unter dem RGB-Ring (auch nicht programmierbar) und die blaue, ryhtmisch blinkende LED oberhalb des Reset-Tasters (auch nicht programmierbar).</p>
</div>
</div>
<div class="sect2">
<h3 id="_standard_built_in_led">5.2. Standard built-in LED</h3>
<div class="paragraph">
<p>Die eingebaute blaue LED auf dem Board ist eher schlecht zu sehen (im Vergleich zu der regelmäßig blinkenden blauen "an"-Status LED):</p>
</div>
<div class="imageblock text-left">
<div class="content">
<img src="../images/auriga-Builtin-LED.gif" alt="auriga Builtin LED">
</div>
<div class="title">Abbildung 9. Eingebaute Standard-LED auf dem Board</div>
</div>
<div class="paragraph">
<p>Diese LED wird wie bei allen Arduino-Boards programmiert - man kann das Standard-Blink-Beispielprogramm nehmen:</p>
</div>
<div class="sect3">
<h4 id="_beispielprogramm">5.2.1. Beispielprogramm</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Eingebaute LED auf dem Arduino-Board blinken lassen</span>
<span class="c1">// Dies ist quasi das Standard-Test-Programm für die meisten Arduino-Boards</span>

<span class="kt">int</span> <span class="n">BlueLed</span> <span class="o">=</span> <span class="n">LED_BUILTIN</span><span class="p">;</span> <span class="c1">// Pin 13</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pinMode</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// lang an</span>
  <span class="n">digitalWrite</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
  <span class="n">delay</span> <span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
  <span class="c1">// kurz aus</span>
  <span class="n">digitalWrite</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
  <span class="n">delay</span> <span class="p">(</span><span class="mi">250</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die LED 13 ist an einen PWM-fähigen Pin angeschlossen, daher kann man die LED auch via PWM langsam ein- und ausblenden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Eingebaute LED auf dem Arduino-Board ein- und ausblenden</span>

<span class="kt">int</span> <span class="n">BlueLed</span> <span class="o">=</span> <span class="n">LED_BUILTIN</span><span class="p">;</span> <span class="c1">// Pin 13</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pinMode</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">25</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">analogWrite</span><span class="p">(</span><span class="n">BlueLed</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">delay</span> <span class="p">(</span><span class="mi">40</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">25</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">analogWrite</span><span class="p">(</span><span class="n">BlueLed</span><span class="p">,</span> <span class="p">(</span><span class="mi">25</span><span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">delay</span> <span class="p">(</span><span class="mi">40</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_onboard_leds_kommunikationsmodul">5.3. OnBoard LEDs (Kommunikationsmodul)</h3>
<div class="imageblock text-left">
<div class="content">
<img src="../images/comm-red-blue-LEDs.gif" alt="comm red blue LEDs">
</div>
<div class="title">Abbildung 10. Rote und blaue Kommunikations-Modul-LEDs</div>
</div>
<div class="paragraph">
<p>Es gibt zwei weitere LEDs auf dem Auriga Board und zwar die zwei kleinen roten und blauen LEDs in der Nähe des USB Anschlusses. Diese werden in der Makeblock Bibliothek nicht verwendet, auch nicht in der Firmware. Man kann diese aber mit den Arduino-Standardpins ansprechen, wenn man denn erstmal weiß, an welchen Pins diese LEDs angeklemmt sind.</p>
</div>
<div class="paragraph">
<p>Daher schaut man zuerst mal in den Schaltplan <a href="downloads/MeAuriga_Schaltplan.pdf">MeAuriga_Schaltplan.pdf</a>.
Die zwei LEDs sind im Abschnitt <em>程序更新&amp;无线遥控 (dt. Programmaktualisierung und drahtlose Fernbedienung)</em> aufgeführt:</p>
</div>
<div class="imageblock text-left">
<div class="content">
<img src="../images/Schaltplanauszug_OnBoard_LEDs.png" alt="Schaltplanauszug OnBoard LEDs">
</div>
<div class="title">Abbildung 11. Auszug Schaltplan OnBoard LEDs</div>
</div>
<div class="paragraph">
<p>Diese LEDs sind mit den Pins D0/RX0 und D1/TX0 des MEGA2560 Mikrocontrollers verbunden. Diese LEDs werden hauptsächlich dafür benutzt, die Kommunikation über diese Ports anzuzeigen. Die Anoden der LEDs sind mit +5 Volt verbunden. Also <strong>leuchten</strong> sie, wenn der jeweilige Pin (Kathodenseite) auf <strong>GND gezogen wird (LOW)</strong>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die LEDs sind auch mit dem BLE (Bluetooth Low Energy) und UART Modulen (Universal Asynchronous Receiver/Transmitter) verbunden. Wenn man die LEDs direkt ansteuert, stört das diese Module. Wahrscheinlich ist das auch der Grund, warum die beiden LEDs in der Dokumentation und in der Bibliothek nicht aufgeführt sind.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_beispielprogramm_2">5.3.1. Beispielprogramm</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Programm für wechselseitiges Ein- und Ausschalten der KommunikationsLEDs</span>

<span class="c1">// Auf dem Auriga Board sind die LEDs an Pin 0 und 1 geklemmt und mit +5V verbunden</span>
<span class="kt">int</span> <span class="n">BlueLed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">RedLed</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pinMode</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span> <span class="n">RedLed</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">digitalWrite</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>  <span class="c1">// Blau anschalten</span>
  <span class="n">digitalWrite</span><span class="p">(</span> <span class="n">RedLed</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>  <span class="c1">// Rot ausschalten</span>
  <span class="n">delay</span> <span class="p">(</span><span class="mi">400</span><span class="p">);</span>
  <span class="n">digitalWrite</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span> <span class="c1">// Blau ausschalten</span>
  <span class="n">digitalWrite</span><span class="p">(</span> <span class="n">RedLed</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>   <span class="c1">// Rot anschalten</span>
  <span class="n">delay</span> <span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_12er_rgb_led_ring">5.4. 12er RGB LED Ring</h3>
<div class="paragraph">
<p>Als Zusatzmodul für das Auriga-Board gibt es einen RGB Ring (Typ: ws12812).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/RGBRing.gif" alt="RGBRing">
</div>
<div class="title">Abbildung 12. Rings aus 12 RGBS</div>
</div>
<div class="paragraph">
<p>Der LED Ring wird über einen Controller angesteuert, der am PWM PIN 44 am ATmega 2560 angeschlossen ist.
Die Programmierung des Controllers ist in der Klasse <code>MeRGBLed</code> implementiert, welche über die Include-Datei <code>MeRGBLed.h</code> eingebunden wird. Der RGB-Controller selbst wird über das WS2811/2812 Protokoll angesprochen, was aber die <code>MeRGBLed</code>-Klasse übernimmt.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wer genauer wissen will, wie das Protokoll auf dem an PIN 44 angeschlossenen LED Controllerchip funktioniert, kann das hier nachlesen:</p>
</div>
<div class="paragraph">
<p><a href="https://www.arrow.com/en/research-and-events/articles/protocol-for-the-ws2812b-programmable-led" class="bare">https://www.arrow.com/en/research-and-events/articles/protocol-for-the-ws2812b-programmable-led</a></p>
</div>
<div class="paragraph">
<p>Wenn man dann mal in den Code der Klasse MeRGBLed innerhalb der MakeBlock Bibliothek schaut, dann findet man die im Text erwähnten Timings und den Assembler code zum Übertragen der Daten.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#define w_zeropulse (350)  // +- 150 ns
#define w_onepulse  (900)  // +- 150 ns
#define w_totalperiod (1250)</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Grundsätzlich hält die Klasse eine Datenstruktur für die RGB-Informationen jeder einzelnen RGB. Die Konfiguration der RGB kann nun durch Zugriffsfunktionen wie <code>setColorAt()</code> geändert werden. Dabei wird zunächst nur der interne Zustand des Klassenobjekts geändert. Die Ansteuerung des Controllers selbst und damit das Umschalten der LEDs erfolgt erst beim Aufruf von <code>show()</code>.</p>
</div>
<div class="paragraph">
<p>Die LED 0 (bzw. 1. LED) ist übrigends die LED auf "1 Uhr", wenn man sich das Bild oben anschaut. Die oberste LED ("12 Uhr") ist die LED 11 und LED 2 (bzw. 3. LED) zeigt in Richtung "Vorwärts" des Land Raider Modells.</p>
</div>
<div class="sect3">
<h4 id="_beispielprogramm_3">5.4.1. Beispielprogramm</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Testprogramm für den LED Ring auf dem Auriga Board.</span>

<span class="c1">// Zuerst den Header für das Auriga-Board einbinden</span>
<span class="cp">#include</span> <span class="cpf">&lt;MeAuriga.h&gt;</span><span class="cp">
</span>
<span class="c1">// Der Auriga on-board LED Ring hat 12 LEDs. Zur Vereinfachung der Lesbarkeit</span>
<span class="c1">// legen wir hier ein Define fest.</span>
<span class="cp">#define LEDNUM  12
</span>
<span class="c1">// Beim Auriga-Board steuern wird den on-board LED Ring an.</span>
<span class="c1">// Die Klasse MeRGBLed bietet die Schnittstellenfunktionen dafür.</span>
<span class="c1">// Im Constructor übergeben wir den Port 0</span>
<span class="n">MeRGBLed</span> <span class="nf">led</span><span class="p">(</span> <span class="n">PORT0</span><span class="p">,</span> <span class="n">LEDNUM</span> <span class="p">);</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// LED Ring Controller ist am PWM PIN D44 angeschlossen</span>
  <span class="n">led</span><span class="p">.</span><span class="n">setpin</span><span class="p">(</span> <span class="mi">44</span> <span class="p">);</span>
  <span class="c1">// Nach dem Setzen des Pin muss minimal kurz gewartet werden.</span>
  <span class="c1">// Wenn man den delay()-Aufruf vergisst, dann wird nach dem</span>
  <span class="c1">// led.show() Befehl die erste LED in grün angezeigt.</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="c1">// nun können wir die initalen LED-Werte (alle AUS/SCHWARZ) setzen</span>
  <span class="c1">// (Die Klasse MeRGBLed setzt anfänglich alle LEDs auf schwarz/aus, man kann</span>
  <span class="c1">//  aber auch led.setColor(0,0,0) vor dem led.show() nochmal aufrufen)</span>
  <span class="n">led</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// wir setzen nun unterschiedliche Farben in den LEDs und schalten diese dann jeweils an</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LEDNUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">// alle ausschalten</span>
    <span class="n">led</span><span class="p">.</span><span class="n">setColor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="c1">// die LED mit Index i anschalten</span>
    <span class="n">led</span><span class="p">.</span><span class="n">setColorAt</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">LEDNUM</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">20</span> <span class="p">);</span> <span class="c1">// i = 0...11</span>
    <span class="c1">// LED Einstellungen an den LED controller übertragen</span>
    <span class="c1">// (erst mit diesem Befehl ändern sich tatsächlich die Farben)</span>
    <span class="n">led</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
    <span class="n">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Grundlegende Herangehensweise ist immer:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Farbe ändern einzelner LEDs mit <code>setColorAt()</code> oder aller zusammen mit <code>setColor()</code></p>
</li>
<li>
<p>dann die Farben an den Controller und damit an den LED-Ring übertragen mit <code>show()</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_die_wichtigsten_funktionen_der_mergbled_klasse">5.4.2. Die wichtigsten Funktionen der MeRGBLed Klasse</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Alle RGB mit der gleichen Farbe setzen</span>
<span class="kt">bool</span> <span class="n">MeRGBLed</span><span class="o">::</span><span class="n">setColor</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">red</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">green</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">blue</span><span class="p">);</span>
<span class="c1">// Alle RGB (index=0) setzen, oder einzelne (1-basierte Indizierung; index = 1...LEDNUM)</span>
<span class="kt">bool</span> <span class="n">MeRGBLed</span><span class="o">::</span><span class="n">setColor</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">red</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">green</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">blue</span><span class="p">);</span>
<span class="c1">// Einzelne LED setzen (index = 0...LEDNUM-1); 0-basierte Indizierung der LED</span>
<span class="kt">bool</span> <span class="n">MeRGBLed</span><span class="o">::</span><span class="n">setColorAt</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">red</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">green</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">blue</span><span class="p">);</span>
<span class="c1">// Gesetzte Farben an den Controller und damit an die LED übertragen (500 µs Wartezeit bei jedem Aufruf)</span>
<span class="kt">bool</span> <span class="n">MeRGBLed</span><span class="o">::</span><span class="n">show</span><span class="p">();</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_programmierideen">5.4.3. Programmierideen</h4>
<div class="paragraph">
<p>Den RGB-Ring kann man prima für verschiedene Sachen nutzen, bspw.:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>zur Anzeige von Sensordaten, bspw. den Abstand beim Entfernungssensor</p>
</li>
<li>
<p>Kompassrichtung anzeigen oder Fahrrichtung</p>
</li>
<li>
<p>die verstrichenen Sekunden oder den Zeitverlauf anzeigen</p>
</li>
<li>
<p>oder einfach nur eine coole Knight-Rider Animation bauen</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_onboard_sensoren_licht_schall_temperature_gyroskop">6. OnBoard Sensoren (Licht, Schall, Temperature, Gyroskop)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hier geht es um das Auslesen der verschiedenen OnBoard-Sensoren auf dem Auriga-Board. Auf dem Auriga Board sind 4 Sensortypen platziert:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Schall/Lautstärke</p>
</li>
<li>
<p>Licht/Helligkeit (2 Mal, links und rechts)</p>
</li>
<li>
<p>Temperatur</p>
</li>
<li>
<p>Gyroskop/Neigungssensor</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Nachfolgend wird gezeigt, wie diese Sensoren einzeln auszulesen sind, und welche Genauigkeiten/Wertebereiche zu erwarten sind.</p>
</div>
<div class="sect2">
<h3 id="_lautstärkeschall">6.1. Lautstärke/Schall</h3>
<div class="paragraph">
<p>Der Sound-Sensor auf dem Auriga-Board wird über die Klasse <code>MeSoundSensor</code> (Include-Datei nur <code>MeAuriga.h</code>)
ausgelesen.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Im Gegensatz zu anderen MakeBlock Bausätzen (mBot etc.) ist der Sound-Sensor auf dem Auriga-Board an Port 14 angeschlossen (siehe Variable <code>mePort</code> in der Datei <code>MeAuriga.h</code> und Erklärung dazu in <a href="#chap:basics">Abschnitt 4</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die Klasse hat nur eine sinnvolle Memberfunction: <code>strength()</code>, was die Lautstärke im Bereich 140 bis ~600 ausgibt.</p>
</div>
<div class="sect3">
<h4 id="_beispielprogramm_4">6.1.1. Beispielprogramm</h4>
<div class="paragraph">
<p>Liest kontinuierlich die Lautstärke aus und übergibt diese via serieller Verbindung an den PC und kann dort bspw. mit dem Serial Plotter der Arduino-IDE angezeigt werden.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Testprogramm für den Sound-Sensor am Auriga-Board.</span>
<span class="c1">//</span>
<span class="c1">// ACHTUNG: beim Auriga ist der Sound-Sensor am Port 14 angeschlossen.</span>
<span class="cp">#include</span> <span class="cpf">&lt;MeAuriga.h&gt;</span><span class="cp">
</span>
<span class="n">MeSoundSensor</span> <span class="nf">soundSensor</span><span class="p">(</span><span class="n">PORT_14</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"value:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">soundSensor</span><span class="p">.</span><span class="n">strength</span><span class="p">()</span> <span class="p">);</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/auriga_soundsensor.png" alt="auriga soundsensor">
</div>
<div class="title">Abbildung 13. Im SerialPlotter sieht man die erfassten Werte, als ich mehrfach laut direkt über dem Auriga-Board geklatscht habe. In sehr leiser Umgebung rauscht das Signal bei ca. 130&#8230;&#8203;140.</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lichthelligkeit">6.2. Licht/Helligkeit</h3>
<div class="paragraph">
<p>Es gibt zwei Helligkeitssensoren auf dem Auriga Board:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>neben Port 2, wird über PORT_11 angesteuert</p>
</li>
<li>
<p>neben Port 9, wird über PORT_12 angesteuert</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Im Gegensatz zu anderen MakeBlock Bausätzen (mBot etc.) sind die Lichtsensoren auf dem Auriga-Board
an den Ports 11 und 12 angeschlossen (siehe Variable <code>mePort</code> in der Datei <code>MeAuriga.h</code> und Erklärung dazu in <a href="#chap:basics">Abschnitt 4</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die Klasse <code>MeLightSensor</code> liest die Helligkeitswerte aus (im Bereich 0..1000) (Memberfunktion <code>read()</code>).</p>
</div>
<div class="sect3">
<h4 id="_beispielprogramm_5">6.2.1. Beispielprogramm</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Test für die Lichtsensoren</span>
<span class="cp">#include</span> <span class="cpf">&lt;MeAuriga.h&gt;</span><span class="cp">
</span>
<span class="n">MeLightSensor</span> <span class="nf">lightSensorRight</span><span class="p">(</span><span class="n">PORT_11</span><span class="p">);</span> <span class="c1">// Der Sensor neben Port 2</span>
<span class="n">MeLightSensor</span> <span class="nf">lightSensorLeft</span><span class="p">(</span><span class="n">PORT_12</span><span class="p">);</span>  <span class="c1">// Der Sensor neben Port 9</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Lichtsensoren auslesen</span>
  <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">lightSensorRight</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">lightSensorLeft</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>

  <span class="c1">// Werte via serieller Verbindung an PC senden</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"min:0,max:1000,"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"left:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",right:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
  <span class="c1">// alle 50 ms</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/auriga_lightsensors.png" alt="auriga lightsensors">
</div>
<div class="title">Abbildung 14. Bei direkten Anleuchten mit einer Fahrradlampe wurde der Wert 1000 ausgegeben. In sehr dunklen Räumen (nur der Monitor in 30 cm Entfernung ist an), zeigt der Sensor Werte zwischen 1-3. Im Beispiel oben habe ich wechselseitig den einen und dann den anderen Sensor mit der Hand abgedeckt.</div>
</div>
<div class="paragraph">
<p><em>Interessant:</em> bei moderatem Licht von Energiesparlampen zeigt der Sensor (wellenförmige schwankende) Werte zwischen 55 und 140 an.</p>
</div>
<div class="paragraph">
<p><em>Auch interessant:</em> Wenn man den Ranger seitlich ans Fenster stellt, so werden leicht unterschiedliche Helligkeitswerte angezeigt. Eine Drehung um 180° führt jedoch wieder Erwarten <em>nicht</em> zum Vertauschen der Helligkeitswerte beider Sensoren, wie man das vielleicht erwarten würde. Ein Regeln der Ausrichtung des Ranges basierend auf seitlich einfallendem Licht scheint eher schwierig zu sein (selber ausprobieren!).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_temperatur">6.3. Temperatur</h3>
<div class="paragraph">
<p>Auf dem Board ist ein DS18B20 Temperatursensor verbunden. Dieser wird über das Wire-Protokoll am Port 13 abgefragt. Die entsprechende Implementierung steckt in der Klasse <code>MeOnBoardTemp</code> mit der Member-Funktion <code>readValue()</code> (bzw. <code>readAnalog()</code> für den Rohwert).</p>
</div>
<div class="sect3">
<h4 id="_beispielprogramm_6">6.3.1. Beispielprogramm</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Test für den Temperatursensor</span>
<span class="cp">#include</span> <span class="cpf">&lt;MeAuriga.h&gt;</span><span class="cp">
</span>
<span class="c1">// Der OnBoard-Temperatursensor wird über Port 13 angesprochen</span>
<span class="n">MeOnBoardTemp</span> <span class="nf">tempSensor</span><span class="p">(</span><span class="n">PORT_13</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Analogwert:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">tempSensor</span><span class="p">.</span><span class="n">readAnalog</span><span class="p">());</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",Temperaturwert:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">tempSensor</span><span class="p">.</span><span class="n">readValue</span><span class="p">());</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/auriga_temperatursensor.png" alt="auriga temperatursensor">
</div>
<div class="title">Abbildung 15. Vom Sensor gelieferter Temperaturverlauf, wenn man den Arduino nach längerer Zeit (6h) erstmalig anschaltet. Ausgehend von der Raumtemperatur (ca. 22°) erwärmt sich das Board und der Sensor in wenigen Minuten auf über 25°C, wenn man noch ein paar LEDs anmacht, oder dem Mikroprozessor ordentlich was zu tun gibt, geht die Temperatur rauf auf knapp 30°C.</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Achtung"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Der Temperatursensor wird maßgeblich durch die Energieabgabe von LEDs und des Prozessors allgemein beeinflusst. Die Umgebungstemperatur lässt sich damit nur sehr ungenau messen, da die Wärmezirkulation zum Sensor durch das Plastikgehäuse behindert ist.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gyroskop">6.4. Gyroskop</h3>
<div class="paragraph">
<p>Das Auriga-Board hat einen Neigungssensor verbaut. Dieser liefert für die 3 Achsen x,y,z jeweils Neigungswerte/Ausrichtungswerte und dazu die Beschleunigungen auf den 3 Achsen.</p>
</div>
<div class="paragraph">
<p>Die Achsenzuordnung ist dabei wie folgt:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>X-Achse : Kippen um die Querachse (<em>der Anstieg beim Fahren auf einen Hügel</em>): -90° (nach unten)&#8230;&#8203;90° (nach oben)</p>
</li>
<li>
<p>Y-Achse : Kippen um die Längsachse; -90° (nach rechts geneigt) &#8230;&#8203;90° (nach links geneigt)</p>
</li>
<li>
<p>Z-Achse :  N, O, S, W Ausrichtung; 0° = der USB-Port am Auriga zeigt dann nach Norden; -180°/180° = der USB-Port zeigt nach Süden; -90° = der USB-Port zeigt nach Westen</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Entsprechend ist die X-Beschleunigung die Beschleunigung vorwärts und Y-Beschleunigung die Drehbeschleunigung. Interessant ist die Z-Beschleunigung (Querbeschleunigung) beim schnellen Kurvenfahren.</p>
</div>
<div class="paragraph">
<p>Zum Auslesen des Neigungssensors/Gyroskops verwendet man die Klasse <code>MeGyro</code> wie im nachfolgendem Beispiel gezeigt.</p>
</div>
<div class="sect3">
<h4 id="_beispielprogramm_7">6.4.1. Beispielprogramm</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Testprogramm für den Neigungssensor</span>
<span class="cp">#include</span> <span class="cpf">&lt;MeAuriga.h&gt;</span><span class="cp">
</span>
<span class="n">MeGyro</span> <span class="nf">gyro</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GYRO_DEFAULT_ADDRESS</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>

  <span class="c1">// Klasse initialisieren</span>
  <span class="n">gyro</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Aktualisiere Zustand des gyro-Objects (liest Sensoren aus und berechnet Winkel/Beschleunigungen)</span>
  <span class="c1">// Alternativ kann man auch fast_update() verwenden</span>
  <span class="n">gyro</span><span class="p">.</span><span class="n">update</span><span class="p">();</span>

  <span class="c1">// greife auf die Sensordaten zu</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Angle-X:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">gyro</span><span class="p">.</span><span class="n">getAngleX</span><span class="p">());</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",Angle-Y:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">gyro</span><span class="p">.</span><span class="n">getAngleY</span><span class="p">());</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",Angle-Z:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">gyro</span><span class="p">.</span><span class="n">getAngleZ</span><span class="p">());</span>

  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",Gyro-X:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">gyro</span><span class="p">.</span><span class="n">getGyroX</span><span class="p">());</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",Gyro-Y:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">gyro</span><span class="p">.</span><span class="n">getGyroY</span><span class="p">());</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",Gyro-Z:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">gyro</span><span class="p">.</span><span class="n">getGyroZ</span><span class="p">());</span>

  <span class="n">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_programmierideen_2">6.5. Programmierideen</h3>
<div class="ulist">
<ul>
<li>
<p>Der Roboter soll im Dunkeln das LED-Licht anschalten (aber beeinflusst das nicht die Helligkeitsmessung?)</p>
</li>
<li>
<p>Der Roboter soll sich zur Lärmquelle hinbewegen (dazu braucht man noch den Antrieb aus <a href="#chap:motors">Abschnitt 8</a>)</p>
</li>
<li>
<p>Der Roboter fährt ein Rampe hoch und hält dann auf der waagerechten Fläche wieder an</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Für den Nervous Bird (das umgedrehte Pendel) ist der Neigungssensor essentiell, damit man hier das Gleichgewicht hält. Die Programmierung eines solchen Robotermodells, der beim anschubsen selbständig vor-/zurück fährt und das Gleichgewicht behält, ist aber ein anspruchsvolleres Projekt.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_töne_mit_dem_passiven_buzzer_auf_dem_board">7. Töne mit dem passiven Buzzer auf dem Board</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hier steuern wir den passiven Buzzer auf dem Board an.</p>
</div>
<div class="sect2">
<h3 id="_allgemeines_2">7.1. Allgemeines</h3>
<div class="paragraph">
<p>Auf dem Auriga-Board ist ein passiver Buzzer verbaut, welcher an einen PWM-Pin angeschlossen ist. Der Buzzer ist an Pin 45 angeschlossen.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/auriga_buzzer.png" alt="auriga buzzer">
</div>
</div>
<div class="paragraph">
<p>Beim Blick in die Include-Datei <code>MeAuriga.h</code> fällt einem am Schluss der Datei folgende Quelltext auf:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#define   pinMode(45,OUTPUT),digitalWrite(45, HIGH)
#define buzzerOff() pinMode(45,OUTPUT),digitalWrite(45, LOW)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Hier wird also beim Einschalten der Pegel auf HIGH gezogen und beim Ausschalten der Pegel wieder auf LOW. Das ist allerdings Code, der für einen aktiven Buzzer gedacht ist, und wahrscheinlich vergessen wurde, zu entfernen.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Achtung"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Für den MakeBlock ranger sind die Funktionen <code>buzzerOn()</code> und <code>buzzerOff()</code> <span class="underline">nicht</span> zu verwenden.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Um den passiven Buzzer anzusteuern, verwendet man <code>tone()</code> und zum Ausschalten <code>noTone()</code>. Hier ist ein Beispiel für die direkte Ansteuerung des Pins.</p>
</div>
<div class="sect3">
<h4 id="_beispielprogramm_8">7.1.1. Beispielprogramm</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#define BUZZER_PIN 45
</span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span>  <span class="p">{</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span>  <span class="p">{</span>
  <span class="n">tone</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">,</span> <span class="mi">131</span><span class="p">);</span>   <span class="c1">// c</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">1200</span><span class="p">);</span>

  <span class="n">tone</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">,</span> <span class="mi">165</span><span class="p">);</span>   <span class="c1">// e</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">400</span><span class="p">);</span>

  <span class="n">tone</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">,</span> <span class="mi">196</span><span class="p">);</span>   <span class="c1">// g</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">1800</span><span class="p">);</span>

  <span class="n">noTone</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">);</span>     <span class="c1">// aus</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">4000</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Hier ist noch ein Programm, bei dem aus dem einfachen Buzzer etwas interessantere Geräusche raus kommen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#define BUZZER_PIN 45
</span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span>  <span class="p">{</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span>  <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">35</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">freq</span> <span class="o">=</span> <span class="mi">80</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mi">10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">terz</span> <span class="o">=</span> <span class="n">freq</span><span class="o">*</span><span class="mf">6.0</span><span class="o">/</span><span class="mi">5</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">tone</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>
      <span class="n">delay</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
      <span class="n">tone</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">,</span> <span class="n">terz</span><span class="p">);</span>
      <span class="n">delay</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">35</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">freq</span> <span class="o">=</span> <span class="mi">80</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mi">10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">terz</span> <span class="o">=</span> <span class="n">freq</span><span class="o">*</span><span class="mf">6.0</span><span class="o">/</span><span class="mi">5</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">tone</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>
      <span class="n">delay</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
      <span class="n">tone</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">,</span> <span class="n">terz</span><span class="p">);</span>
      <span class="n">delay</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Eine Liste von Frequenzen für die ersten 6 Oktaven findet man im Arduino-Beispiel: <code>02. Digital-&gt;toneMelody</code> und der dort enthaltenen Datei <code>pitches.h</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_verwendung_der_makeblock_klasse_mebuzzer">7.2. Verwendung der Makeblock Klasse MeBuzzer</h3>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Achtung"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Nur für den Anschluss externer Buzzer sinnvoll!</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In der Makeblock-Bibliothek gibt es noch die Klasse <code>MeBuzzer</code>. Diese kapselt den Zugriff zwar etwas, macht die Ansteuerung des Buzzers aber nicht wirklich einfacher.</p>
</div>
<div class="paragraph">
<p>Man kann mittels der Member-Funktion <code>MeBuzzer::tone(frequenz, dauer in ms)</code> einen Ton ausgeben. Diese Funktion implementiert einen Software-PWM (d.h. in dieser Funktion wird der angegebene Buzzer-Pin sehr häufig an und aus geschaltet, wobei das Verhältnis der an/aus-Zeiten die Tonhöhe definiert).</p>
</div>
<div class="paragraph">
<p>Somit kann man auch externe Buzzer anschließen und dabei Ports mit digitalen Pins (keine analogen/PWM Pins) nutzen.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Für die Verwendung des OnBoard-Buzzers sollte man die <code>MeBuzzer</code>-Klasse <em>nicht</em> benutzen, sondern stattdessen wie im Beispiel oben via <code>tone()</code> die Frequenz einstellen. Das hat auch den Vorteil, dass man ohne Wartezeiten parallel zum Melodie abspielen noch Sensoren auslesen und andere Dinge steuern kann.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_beispielprogramm_9">7.2.1. Beispielprogramm</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Beispielprogramm für die Verwendung der MeBuzzer-Klasse</span>
<span class="c1">// Diese Variante ist aber NICHT EMPFOHLEN (siehe Text)</span>
<span class="cp">#include</span> <span class="cpf">&lt;MeAuriga.h&gt;</span><span class="cp">
</span>
<span class="cp">#define BUZZER_PIN 45
</span>
<span class="n">MeBuzzer</span> <span class="n">buzzer</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span>  <span class="p">{</span>
  <span class="n">buzzer</span><span class="p">.</span><span class="n">setpin</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">);</span>
  <span class="n">buzzer</span><span class="p">.</span><span class="n">noTone</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span>  <span class="p">{</span>
  <span class="n">buzzer</span><span class="p">.</span><span class="n">tone</span><span class="p">(</span><span class="mi">262</span><span class="p">,</span> <span class="mi">250</span><span class="p">);</span>   <span class="c1">//NOTE_C4</span>
  <span class="n">buzzer</span><span class="p">.</span><span class="n">tone</span><span class="p">(</span><span class="mi">294</span><span class="p">,</span> <span class="mi">250</span><span class="p">);</span>   <span class="c1">//NOTE_D4</span>
  <span class="n">buzzer</span><span class="p">.</span><span class="n">tone</span><span class="p">(</span><span class="mi">330</span><span class="p">,</span> <span class="mi">250</span><span class="p">);</span>   <span class="c1">//NOTE_E4</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>

  <span class="n">buzzer</span><span class="p">.</span><span class="n">tone</span><span class="p">(</span><span class="mi">587</span><span class="p">,</span> <span class="mi">250</span><span class="p">);</span>   <span class="c1">//NOTE_D5</span>
  <span class="n">buzzer</span><span class="p">.</span><span class="n">tone</span><span class="p">(</span><span class="mi">659</span><span class="p">,</span> <span class="mi">250</span><span class="p">);</span>   <span class="c1">//NOTE_E5</span>
  <span class="n">buzzer</span><span class="p">.</span><span class="n">tone</span><span class="p">(</span><span class="mi">523</span><span class="p">,</span> <span class="mi">250</span><span class="p">);</span>   <span class="c1">//NOTE_C5</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chap:motors">8. Motorsteuerung</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Jetzt wird endlich mal was bewegt. In diesem Teil geht es um die Programmierung der Motoren.</p>
</div>
<div class="sect2">
<h3 id="_allgemeines_3">8.1. Allgemeines</h3>
<div class="paragraph">
<p>Am Auriga-Board gibt es zwei Motorports. Jeder der Motoren kann über einen PWM Pin (für die Geschwindigkeit) und zwei Richtungspins angesteuert werden. Die Ansteuerung kann einmal direkt über die Arduino-Pins erfolgen oder unter Verwendung der Makeblock Bibliothek.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Grundsätzlich bewegen sich die Motoren nur, wenn die Spannungsversorgung über die Batterien erfolgt (die Motoren brauchen eine Spannung &gt; 7V, was der USB-Port ja nicht liefern kann). Das ist auch ganz praktisch, da man so den Robotor angesteckt an den Computer programmieren kann, ohne Angst zu haben, dass er vom Tisch rollt.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die Motoren werden an die beiden Motorports angesteckt:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/auriga_motorports.png" alt="auriga motorports">
</div>
<div class="title">Abbildung 16. Motor-Ports an der Auriga-Platine</div>
</div>
</div>
<div class="sect2">
<h3 id="_direkte_ansteuerung_über_pwm_und_digitale_pins">8.2. Direkte Ansteuerung über PWM und digitale Pins</h3>
<div class="paragraph">
<p>Aus dem Schaltplan kann man die Bezeichnung der digitalen Pins (D46&#8230;&#8203;D49) und die PWM Pins (D10, D11) entnehmen:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/auriga_schaltplanauszug_motor.png" alt="auriga schaltplanauszug motor">
</div>
<div class="title">Abbildung 17. Schaltplanauszug für die Motoransteuerung</div>
</div>
<div class="paragraph">
<p>Die Pins werden nun wie folgt angesprochen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>PWMA und PWMB erhalten Drehgeschwindigkeiten im Bereich von 0..255</p>
</li>
<li>
<p>DIRA1 und DIRA2 regeln die Richtung des Motors A (links) und müssen jeweils entgegengesetzt geschaltet sein</p>
</li>
<li>
<p>DIRB1 und DIRB2 regeln die Richtung des Motors B (rechts) und müssen jeweils entgegengesetzt geschaltet sein</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_beispielprogramm_direkte_ansteuerung">8.2.1. Beispielprogramm - Direkte Ansteuerung</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Testprogramm für die Ansteuerung der DC-Motoren via Arduino Pins</span>

<span class="cp">#define PWMA  11 // Motor A/Links
#define DIRA1 49
#define DIRA2 48
#define PWMB  10 // Motor B/Rights
#define DIRB1 47
#define DIRB2 46
</span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// PWM und Richtungspins setzen</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">PWMA</span><span class="p">,</span>  <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">DIRA1</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">DIRA2</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">PWMB</span><span class="p">,</span>  <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">DIRB1</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">DIRB1</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>

  <span class="c1">// kurze Wartephase zur Initialisierung</span>
  <span class="n">delay</span> <span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">leftMotorSpeed</span><span class="p">(</span><span class="kt">int</span> <span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">analogWrite</span> <span class="p">(</span><span class="n">PWMA</span><span class="p">,</span>  <span class="n">speed</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRA1</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRA2</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">analogWrite</span> <span class="p">(</span><span class="n">PWMA</span><span class="p">,</span>  <span class="o">-</span><span class="n">speed</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRA1</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRA2</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">rightMotorSpeed</span><span class="p">(</span><span class="kt">int</span> <span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">analogWrite</span> <span class="p">(</span><span class="n">PWMB</span><span class="p">,</span>  <span class="n">speed</span><span class="p">);</span>
      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRB1</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRB2</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">analogWrite</span> <span class="p">(</span><span class="n">PWMB</span><span class="p">,</span>  <span class="o">-</span><span class="n">speed</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRB1</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRB2</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// Maximalgeschwindigkeit, falls die Akkus langsam schlapp machen, sollte man hier kleinere Zahlenwerte nehmen</span>
<span class="kt">int</span> <span class="n">maxSpeed</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">upward</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// Steuerungsprogramm:</span>
  <span class="c1">// - Vorwärtsfahren und Geschwindigkeit in jeder Schleife erhöhen bis Maximalgeschwindikeit erreicht ist</span>
  <span class="c1">// - dann langsamer werden und schließlich Rückwärtsfahren bis maximale Rückwärtsgeschwindigkeit erreicht ist</span>
  <span class="c1">// - dann wieder umschalten auf vorwärts fahren</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">upward</span><span class="p">)</span>
    <span class="n">speed</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">speed</span> <span class="o">-=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&gt;</span> <span class="n">maxSpeed</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">upward</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">speed</span> <span class="o">=</span> <span class="n">maxSpeed</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">maxSpeed</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">upward</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">speed</span> <span class="o">=</span> <span class="o">-</span><span class="n">maxSpeed</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Motorgeschwindigkeiten anpassen</span>
  <span class="n">leftMotorSpeed</span><span class="p">(</span><span class="n">speed</span><span class="p">);</span>
  <span class="n">rightMotorSpeed</span><span class="p">(</span><span class="n">speed</span><span class="p">);</span>

  <span class="n">delay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Hier fährt der Roboter einfach nur vor und zurück und beschleunigt/bremst dabei.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ansteuerung_über_encoder_klasse_der_bibliothek">8.3. Ansteuerung über Encoder-Klasse der Bibliothek</h3>
<div class="paragraph">
<p>Die MakeBlock-Bibliothek bietet zahlreiche Klassen für die Programmierung von Encodern. Für die mitgelieferten DC-Motoren wird die Klasse <code>MeEncoderOnBoard</code> verwendet. Diese übernimmt, wie der Name schon sagt, die Programmierung der auf dem Board befindlichen Motorsteuerung.</p>
</div>
<div class="paragraph">
<p>Diese Art der Programmierung hat den Vorteil, dass man die konkrete Geschwindigkeit und damit auch Position abfragen kann und somit - zumindest in Theorie - den Roboter sehr präzise bewegen kann.</p>
</div>
<div class="paragraph">
<p>Die Encoder liefern Bewegungsimpulse, die man zählen kann, um so Geschwindigkeit und Entfernung zu bestimmen. Damit man das präzise machen kann, ohne dass anderen Aufgaben im Mikroprozessor die Messung beeinträchtigen, verwendet man Interruptfunktionen. Dazu registriert man für jeden Motor eine Interruptfunktion, die immer dann aufgerufen wird, wenn am entsprechenden Pin ein RISING Signal anliegt (also der Eingangspin von LOW auf HIGH wechselt). In der Interruptfuktion wird dann ein Zähler hochgezählt, der dann für die Berechnung der Momentangeschwindigkeit und Bewegung verwendet wird. Die Berechnung selbst ist in der Klasse <code>MeEncoderOnBoard</code> gekapselt.</p>
</div>
<div class="sect3">
<h4 id="sec:motor:encodertest">8.3.1. Beispielprogramm - Ansteuerung mittels Bibliotheksfunktion</h4>
<div class="paragraph">
<p>Im Folgenden Testbeispiel kann man den Robotor begrenzt steuern:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Nach Start des Programms den SerialMonitor der Arduino-IDE aufrufen</p>
</li>
<li>
<p>in die Zeile "Nachricht" des SerialMonitor eine Zahl 0&#8230;&#8203;6 eintippen und mit Enter abschicken</p>
</li>
<li>
<p>das Programm wertet diese Zahl aus und legt die Drehgeschwindigkeit der Motoren fest</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Das Testbeispiel enthält eine Menge Details, welche weiter unten erklärt werden.</p>
</div>
<div class="listingblock">
<div class="title">Kleines Testprogramm für die Motorsteuerung und Messung der Geschwindigkeit mittels der Encoder-Bibliothek</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Testprogramm für die Ansteuerung der DC Motoren via Makeblock Bibliothek</span>
<span class="cp">#include</span> <span class="cpf">&lt;MeAuriga.h&gt;</span><span class="cp">
</span>
<span class="n">MeEncoderOnBoard</span> <span class="nf">Encoder_1</span><span class="p">(</span><span class="n">SLOT1</span><span class="p">);</span>
<span class="n">MeEncoderOnBoard</span> <span class="nf">Encoder_2</span><span class="p">(</span><span class="n">SLOT2</span><span class="p">);</span>

<span class="c1">// Für präzise Messung der Geschwindigkeit (und damit Position) der Motoren</span>
<span class="c1">// werden die Pulse via Interruptfunktionen hoch/runtergezählt.</span>
<span class="c1">// Jedes Mal, wenn der Interrupt-Pin eines Encoders von LOW auf HIGH wechselt (RISING),</span>
<span class="c1">// wird die jeweilige isr_process_encoderX() Funktion aufgerufen und zählt einen</span>
<span class="c1">// Pulse hoch.</span>

<span class="c1">// Interruptfunktion für Encoder 1</span>
<span class="kt">void</span> <span class="nf">isr_process_encoder1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">digitalRead</span><span class="p">(</span><span class="n">Encoder_1</span><span class="p">.</span><span class="n">getPortB</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">Encoder_1</span><span class="p">.</span><span class="n">pulsePosMinus</span><span class="p">();</span>
  <span class="k">else</span>
    <span class="n">Encoder_1</span><span class="p">.</span><span class="n">pulsePosPlus</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Interruptfunktion für Encoder 2</span>
<span class="kt">void</span> <span class="n">isr_process_encoder2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">digitalRead</span><span class="p">(</span><span class="n">Encoder_2</span><span class="p">.</span><span class="n">getPortB</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">Encoder_2</span><span class="p">.</span><span class="n">pulsePosMinus</span><span class="p">();</span>
  <span class="k">else</span>
    <span class="n">Encoder_2</span><span class="p">.</span><span class="n">pulsePosPlus</span><span class="p">();</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="n">lastOutputMillis</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">targetSpeedPWM</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Festlegen der Interruptfunktionen für das Messen/Zählen der Bewegung</span>
  <span class="n">attachInterrupt</span><span class="p">(</span><span class="n">Encoder_1</span><span class="p">.</span><span class="n">getIntNum</span><span class="p">(),</span> <span class="n">isr_process_encoder1</span><span class="p">,</span> <span class="n">RISING</span><span class="p">);</span>
  <span class="n">attachInterrupt</span><span class="p">(</span><span class="n">Encoder_2</span><span class="p">.</span><span class="n">getIntNum</span><span class="p">(),</span> <span class="n">isr_process_encoder2</span><span class="p">,</span> <span class="n">RISING</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>

  <span class="c1">// Interne Timer der PWM auf 8KHz programmieren</span>
  <span class="n">TCCR1A</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM10</span><span class="p">);</span>
  <span class="n">TCCR1B</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">CS11</span><span class="p">)</span> <span class="o">|</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM12</span><span class="p">);</span>

  <span class="n">TCCR2A</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM21</span><span class="p">)</span> <span class="o">|</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM20</span><span class="p">);</span>
  <span class="n">TCCR2B</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">CS21</span><span class="p">);</span>

  <span class="c1">// Variable für gelegentliche Ausgaben auf die serielle Schnittstelle</span>
  <span class="n">lastOutputMillis</span> <span class="o">=</span> <span class="n">millis</span><span class="p">();</span>
  <span class="n">targetSpeedPWM</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// von der seriellen Schnittstelle lesen</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Serial</span><span class="p">.</span><span class="n">available</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Zeichen 0...6 werden gelesen</span>
    <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Serial</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="sc">'0'</span><span class="p">:</span> <span class="n">targetSpeedPWM</span> <span class="o">=</span>    <span class="mi">0</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">// stop</span>
      <span class="k">case</span> <span class="sc">'1'</span><span class="p">:</span> <span class="n">targetSpeedPWM</span> <span class="o">=</span>  <span class="mi">100</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">// slow forward</span>
      <span class="k">case</span> <span class="sc">'2'</span><span class="p">:</span> <span class="n">targetSpeedPWM</span> <span class="o">=</span>  <span class="mi">200</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">// fast forward</span>
      <span class="k">case</span> <span class="sc">'3'</span><span class="p">:</span> <span class="n">targetSpeedPWM</span> <span class="o">=</span>  <span class="mi">255</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">// fastest forward</span>
      <span class="k">case</span> <span class="sc">'4'</span><span class="p">:</span> <span class="n">targetSpeedPWM</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">// slow backward</span>
      <span class="k">case</span> <span class="sc">'5'</span><span class="p">:</span> <span class="n">targetSpeedPWM</span> <span class="o">=</span> <span class="o">-</span><span class="mi">200</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">// fast backward</span>
      <span class="k">case</span> <span class="sc">'6'</span><span class="p">:</span> <span class="n">targetSpeedPWM</span> <span class="o">=</span> <span class="o">-</span><span class="mi">255</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">// fastest backward</span>
    <span class="p">}</span>
    <span class="n">Encoder_1</span><span class="p">.</span><span class="n">setTarPWM</span><span class="p">(</span><span class="o">-</span><span class="n">targetSpeedPWM</span><span class="p">);</span>
    <span class="n">Encoder_2</span><span class="p">.</span><span class="n">setTarPWM</span><span class="p">(</span><span class="n">targetSpeedPWM</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// In der loop() Funktion wird die Geschwindigkeit im Motor geregelt</span>
  <span class="n">Encoder_1</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span>
  <span class="n">Encoder_2</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span>

  <span class="c1">// alle 100 Millisekunden die Geschwindigkeit ausgeben</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">millis</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">lastOutputMillis</span> <span class="o">+</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lastOutputMillis</span> <span class="o">=</span> <span class="n">millis</span><span class="p">();</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Target speed [PWM]:"</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">targetSpeedPWM</span><span class="p">);</span>
    <span class="c1">// Erreichte Geschwindigkeit</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",Speed 1:"</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="o">-</span><span class="n">Encoder_1</span><span class="p">.</span><span class="n">getCurrentSpeed</span><span class="p">());</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",Speed 2:"</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">Encoder_2</span><span class="p">.</span><span class="n">getCurrentSpeed</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In diesem Code werden einige fortgeschrittene Arduino-Programmier-Techniken verwendet, die nachfolgend etwas genauer beleuchtet werden.</p>
</div>
</div>
<div class="sect3">
<h4 id="_interrupts_für_encoder_signale">8.3.2. Interrupts für Encoder-Signale</h4>
<div class="paragraph">
<p>Die in den Motoren verbauten Encoder liefern an jeweils 2 Pins die Encoder-Signale aus, wobei jeweils einer der Pins ein Interrupt-fähiger Pin ist. Zunächst werden die Funktionen <code>isr_process_encoder1()</code> und <code>isr_process_encoder2()</code> an Interrupts gebunden, wobei auf den Wechsel des Pegels von low auf high reagiert wird (<code>RISING</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Verknüpfung einer Interrupt-Funktion</span>
<span class="n">attachInterrupt</span><span class="p">(</span><span class="n">Encoder_1</span><span class="p">.</span><span class="n">getIntNum</span><span class="p">(),</span> <span class="n">isr_process_encoder1</span><span class="p">,</span> <span class="n">RISING</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Funktion <code>Encoder_1.getIntNum()</code> liefert dabei die Interruptnummer für den interruptfähigen Pin.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Auf dem Mega 2560 gibt es mehrere Interrupt-fähige Pins, unter anderem Pin 18 und 19, welche mit dem Encoder verbunden sind (siehe auch Pinout-Diagramm, M1 und M2, wo D19/INT1 und D18/INT3 steht. Diesen Pins wird im Mega 2560 jeweils eine Interrupt-Nummer zugewiesen. Normalerweise bekommt man die über die Funktion <code>digitalPinToInterrupt()</code> die zu einem Interrupt-fähigen Pin zugehörige Internetnummer und genau dies liefert die Funktion <code>getIntNum()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">int</span> <span class="n">interruptNr1</span> <span class="o">=</span> <span class="n">digitalPinToInterrupt</span><span class="p">(</span><span class="mi">19</span><span class="p">);</span>  <span class="c1">// -&gt; interrupt 4, genau wie Encoder_1.getIntNum()</span>
<span class="kt">int</span> <span class="n">interruptNr2</span> <span class="o">=</span> <span class="n">digitalPinToInterrupt</span><span class="p">(</span><span class="mi">18</span><span class="p">);</span>  <span class="c1">// -&gt; interrupt 5, genau wie Encoder_2.getIntNum()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Siehe auch Erklärung zu den Interrupt-Nummern in <a href="https://docs.arduino.cc/language-reference/funktionen/external-interrupts/attachInterrupt/" class="bare">https://docs.arduino.cc/language-reference/funktionen/external-interrupts/attachInterrupt/</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Wie bei Encodern üblich wird die Flanke des einen Pins überwacht, und dann durch den (etwas versetzten Pegel des 2. Pins) die Drehrichtung bestimmt. Dies geschicht in der Interrupt-Funktion:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">void</span> <span class="nf">isr_process_encoder1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Encoder_1.getPortA() -&gt; Pin 19</span>
  <span class="c1">// Encoder_1.getPortB() -&gt; Pin 42</span>

  <span class="c1">// wenn der 2. Encoder-Pin gleichzeitig High ist, dreht sich der Encoder vorwärts</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">digitalRead</span><span class="p">(</span><span class="n">Encoder_1</span><span class="p">.</span><span class="n">getPortB</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">Encoder_1</span><span class="p">.</span><span class="n">pulsePosMinus</span><span class="p">();</span>
  <span class="k">else</span>
    <span class="c1">// sonst rückwärts</span>
    <span class="n">Encoder_1</span><span class="p">.</span><span class="n">pulsePosPlus</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Encoder zählen jetzt also bei jedem Aufruf einen Puls höher oder runter. In der in jedem Durchlauf aufgerufenen Funktion <code>MeEncoderOnBoard::loop()</code> wird die Funktion <code>MeEncoderOnBoard::updateSpeed()</code> aufgerufen, welche letztlich die Anzahl der Pulse seit dem letzten Aufruf von <code>updateSpeed()</code> in die Drehgeschwindigkeit umrechnet.</p>
</div>
</div>
<div class="sect3">
<h4 id="_testlauf_und_geschwindigkeitsmessung_mit_und_ohne_kette">8.3.3. Testlauf und Geschwindigkeitsmessung mit und ohne Kette</h4>
<div class="paragraph">
<p>Wenn man jetzt das Programm mal testet, zuerst noch ohne den Codeblock in der <code>setup()</code> Funktion mit den umprogrammierten PWM-Timern, und die Geschwindigkeiten plottet erhält man ein interessantes Bild:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/auriga_encoder_speed_original_PWM_timer_one_belt.png" alt="auriga encoder speed original PWM timer one belt">
</div>
<div class="title">Abbildung 18. Ausgabe der Motorgeschwindigkeiten mit originalen PWM-Timern und jeweils einen Motor mit Kette und den anderen Motor freidrehend</div>
</div>
<div class="paragraph">
<p>Da die Kette schwingt und auch nicht gleichmäßig steif ist, führt dies zu ungleichmäßigen Drehbewegungen des Motors. Um diesen Einfluss zu sehen, habe ich an einen Motor die Kette angebaut und am anderen Motor nicht. Klar erkennbar im Diagramm ist auch die Bremswirkung dder Kette insgesamt - der Motor mit Kette dreht langsamer.</p>
</div>
<div class="paragraph">
<p>Außerdem wird die Ziel-PWM-Geschwindigkeit offensichtlich nicht ganz erreicht. Dies liegt daran, dass das generierte PWM-Signal zu langsam ist. Um dies zu beheben, kann der PWM-Timer des Arduino umprogrammiert werden, sodass er mit 8kHz läuft. Dies passiert im Codeblock:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c">  <span class="c1">// Interne Timer der PWM auf 8KHz programmieren</span>
  <span class="n">TCCR1A</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM10</span><span class="p">);</span>
  <span class="n">TCCR1B</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">CS11</span><span class="p">)</span> <span class="o">|</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM12</span><span class="p">);</span>

  <span class="n">TCCR2A</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM21</span><span class="p">)</span> <span class="o">|</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM20</span><span class="p">);</span>
  <span class="n">TCCR2B</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">CS21</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erneut getestet sieht die Geschwindigkeitsausgabe deutlich besser aus, d.h. auch die durch die Encoder erfasste Drehzahl ist auch bei kleineren Drehzahlen hinreichend proportional zur Sollgeschwindigkeit (in PWM).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/auriga_encoder_speed_8kHz_PWM_timer_one_belt.png" alt="auriga encoder speed 8kHz PWM timer one belt">
</div>
<div class="title">Abbildung 19. Ausgabe der Motorgeschwindigkeiten (in Umdrehungen pro Minute) mit umprogrammierten PWM-Timern und jeweils einen Motor mit Kette und den anderen Motor freidrehend</div>
</div>
<div class="paragraph">
<p>Beim freilaufenden Motor wird die festgelegte Soll-Geschwindigkeit offenbar gut erreicht. Beim Motor mit Kette bleibt die Sollgeschwindigkeit etwas hinter der festgelegten Geschwindigkeit, was ja an der Bremswirkung liegt.</p>
</div>
<div class="paragraph">
<p>Im Beispiel oben wurde die Geschwindigkeit in PWM angegeben und die Drehzahl vom Encoder in Umdrehungen pro Minute (RPM) abgelesen.
Die Verhältnisse sind</p>
</div>
<div class="literalblock">
<div class="content">
<pre>132/100 = 1.32
266/200 = 1.33
339/255 = 1.33</pre>
</div>
</div>
<div class="paragraph">
<p>Damit kann man also die geforderte Drehzahl im Bereich -340&#8230;&#8203;340 mit der Formel einstellen:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>pwm = rpm/1.33</pre>
</div>
</div>
<div class="paragraph">
<p>Die Drehzahl eines unbelasteten Rades alleine sagt ja noch nichts über die Fahrgeschwindigkeit des Roboters aus. Dazu muss man erstmal Testmessungen machen. Und natürlich hängt die Geschwindigkeit dann auch noch vom Batterieladezustand ab und vom Anstieg und von der Reibung der Kette und und und&#8230;&#8203; Deshalb ist es sinnvoller, die Leistung anhand der geforderten Geschwindigkeit einzuregeln. Doch dazu später mehr&#8230;&#8203;</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wenn man den Land Raider mit aufgeladenen Batterien und Maximalgeschwindigkeit fahren lässt, so schafft er bei vollen Batterien auf gerader Fläche immerhin <strong>0,56 m/s</strong> bzw. <strong>2 km/h</strong>. Das reicht locker, um durch eine Legostadt zu düsen und spektakuläre Videos aus der Legomännelperspektive zu filmen.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_motorleistung_adaptiv_regeln_mittels_in_der_encoder_klasse">8.4. Motorleistung adaptiv regeln mittels in der Encoder-Klasse</h3>
<div class="paragraph">
<p>Die Ansteuerung via setzen der Ziel-PWM ist di einfachste und direkteste Möglichkeit, den Roboter zu steuern. Aber wie oben erwähnt kann man so kaum eine geforderte Fahrgeschwindigkeit bestimmen. Die Klasse <code>MeEncoderOnBoard</code> bietet aber noch eine zweite Variante, wie man die Geschwindigkeit bzw. Motorleistung definieren kann: einen klassischen PID Regler-Ansatz.</p>
</div>
<div class="paragraph">
<p>Hierbei wird die aktuelle Geschwindigkeit andauernd mit der Sollgeschwindigkeit verglichen. Die Abweichung (der Regelfehler) wird dazu benutzt, um die Leistung/PWM der Motoren solange anzupassen, bis die Ist-Geschwindigkeit der Soll-Geschwindigkeit entspricht und der Regelfehler (nahezu) 0 wird.</p>
</div>
<div class="listingblock">
<div class="title">Beispielprogramm für die adaptive Regelung der Geschwindigkeit</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Testprogramm für die Ansteuerung der DC Motoren via Makeblock Bibliothek</span>
<span class="cp">#include</span> <span class="cpf">&lt;MeAuriga.h&gt;</span><span class="cp">
</span>
<span class="n">MeEncoderOnBoard</span> <span class="nf">Encoder_1</span><span class="p">(</span><span class="n">SLOT1</span><span class="p">);</span>
<span class="n">MeEncoderOnBoard</span> <span class="nf">Encoder_2</span><span class="p">(</span><span class="n">SLOT2</span><span class="p">);</span>

<span class="c1">// Interruptfunktion für Encoder 1</span>
<span class="kt">void</span> <span class="nf">isr_process_encoder1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">digitalRead</span><span class="p">(</span><span class="n">Encoder_1</span><span class="p">.</span><span class="n">getPortB</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>     <span class="n">Encoder_1</span><span class="p">.</span><span class="n">pulsePosMinus</span><span class="p">();</span>
  <span class="k">else</span>                                            <span class="n">Encoder_1</span><span class="p">.</span><span class="n">pulsePosPlus</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Interruptfunktion für Encoder 2</span>
<span class="kt">void</span> <span class="n">isr_process_encoder2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">digitalRead</span><span class="p">(</span><span class="n">Encoder_2</span><span class="p">.</span><span class="n">getPortB</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>     <span class="n">Encoder_2</span><span class="p">.</span><span class="n">pulsePosMinus</span><span class="p">();</span>
  <span class="k">else</span>                                            <span class="n">Encoder_2</span><span class="p">.</span><span class="n">pulsePosPlus</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">lastOutputMillis</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">targetSpeedRPM</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">buffIndex</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Festlegen der Interruptfunktionen für das Messen/Zählen der Bewegung</span>
  <span class="n">attachInterrupt</span><span class="p">(</span><span class="n">Encoder_1</span><span class="p">.</span><span class="n">getIntNum</span><span class="p">(),</span> <span class="n">isr_process_encoder1</span><span class="p">,</span> <span class="n">RISING</span><span class="p">);</span>
  <span class="n">attachInterrupt</span><span class="p">(</span><span class="n">Encoder_2</span><span class="p">.</span><span class="n">getIntNum</span><span class="p">(),</span> <span class="n">isr_process_encoder2</span><span class="p">,</span> <span class="n">RISING</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>

  <span class="c1">// Interne Timer der PWM auf 8KHz programmieren</span>
  <span class="n">TCCR1A</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM10</span><span class="p">);</span>
  <span class="n">TCCR1B</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">CS11</span><span class="p">)</span> <span class="o">|</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM12</span><span class="p">);</span>

  <span class="n">TCCR2A</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM21</span><span class="p">)</span> <span class="o">|</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM20</span><span class="p">);</span>
  <span class="n">TCCR2B</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">CS21</span><span class="p">);</span>

  <span class="c1">// die PID Reglerparameter einstellen, eigentlich nur den P-Teil des Reglers, denn der Integral und Differentialteil</span>
  <span class="c1">// funktionieren gar nicht erst</span>
  <span class="c1">// (der Differentialteil ist bei einem Motor auch nicht sinnvoll, außer der Fahrtwiderstand</span>
  <span class="c1">// ändert sich abrupt... was aber eher unwahrscheinlich ist)</span>
  <span class="n">Encoder_1</span><span class="p">.</span><span class="n">setSpeedPid</span><span class="p">(</span><span class="mf">0.18</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Encoder_2</span><span class="p">.</span><span class="n">setSpeedPid</span><span class="p">(</span><span class="mf">0.18</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// Variable für gelegentliche Ausgaben auf die serielle Schnittstelle</span>
  <span class="n">lastOutputMillis</span> <span class="o">=</span> <span class="n">millis</span><span class="p">();</span>
  <span class="n">targetSpeedRPM</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">buffIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// von der seriellen Schnittstelle lesen</span>

  <span class="c1">// eine maximal 3-stellige Zahl von der seriellen Schnittstelle lesen</span>
  <span class="kt">char</span> <span class="n">lastChar</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">Serial</span><span class="p">.</span><span class="n">available</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">buffIndex</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lastChar</span> <span class="o">=</span> <span class="n">Serial</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
    <span class="c1">// Falls noch weniger &lt; 3 Zeichen und kein Zeilenende, Zeichen in Puffer schieben</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lastChar</span> <span class="o">!=</span> <span class="sc">'\n'</span> <span class="o">&amp;&amp;</span> <span class="n">buffIndex</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
      <span class="n">buf</span><span class="p">[</span><span class="n">buffIndex</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">lastChar</span><span class="p">;</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Zeichenkette in Puffer mit \0 beenden</span>
      <span class="n">buf</span><span class="p">[</span><span class="n">buffIndex</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
      <span class="c1">// Text in Zahl umwandeln</span>
      <span class="n">targetSpeedRPM</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
      <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"targetspeed = "</span><span class="p">);</span>
      <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">targetSpeedRPM</span><span class="p">);</span>
      <span class="c1">// Motorzielgeschwindigkeiten anpassen</span>
      <span class="n">Encoder_1</span><span class="p">.</span><span class="n">runSpeed</span><span class="p">(</span><span class="o">-</span><span class="n">targetSpeedRPM</span><span class="p">);</span>
      <span class="n">Encoder_2</span><span class="p">.</span><span class="n">runSpeed</span><span class="p">(</span><span class="n">targetSpeedRPM</span><span class="p">);</span>
      <span class="n">buffIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// In der loop() Funktion wird die Geschwindigkeit im Motor geregelt</span>
  <span class="n">Encoder_1</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span>
  <span class="n">Encoder_2</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span>

  <span class="c1">// alle 100 Millisekunden die Geschwindigkeit und Duty Cycle ausgeben</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">millis</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">lastOutputMillis</span> <span class="o">+</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lastOutputMillis</span> <span class="o">=</span> <span class="n">millis</span><span class="p">();</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"TargetSpeed:"</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">targetSpeedRPM</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",Speed1:"</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="o">-</span><span class="n">Encoder_1</span><span class="p">.</span><span class="n">getCurrentSpeed</span><span class="p">());</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",PWM1:"</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="o">-</span><span class="n">Encoder_1</span><span class="p">.</span><span class="n">getCurPwm</span><span class="p">());</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",Speed2:"</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">Encoder_2</span><span class="p">.</span><span class="n">getCurrentSpeed</span><span class="p">());</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",PWM2:"</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">Encoder_2</span><span class="p">.</span><span class="n">getCurPwm</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In diesem Programm wird die geforderte Geschwindigkeit über die serielle Schnittstelle gelesen. Im SerialPlotter oder SerialMonitor kann man dazu eine 3-stellige Zahl eingeben. In jedem Schleifendurchlauf wird ein neues Zeichen von der seriellen Schnittstelle in einen Pufferspeicher gelesen, bis entweder ein Zeilenendzeichen (<code>\n</code>) folgt, oder das 4. Zeichen gelesen wurde. Dann wird der Text im  Pufferspeicher mit einem <code>\0</code> beendet und in eine Zahl gewandelt. Diese wird dann als Soll-Drehzahl übergeben (in der etwas unzutreffenden Funktion <code>runSpeed()</code>. Der Controller berechnet in der stets aufgerufenen <code>MeEncoderOnBoard::loop()</code>-Funktion den Regelfehler und passt den Duty Cycle (PWM) entsprechend an.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/auriga_encoder_speed_8kHz_RPM_controlled.png" alt="auriga encoder speed 8kHz RPM controlled">
</div>
<div class="title">Abbildung 20. Geregelte Motorleistung, getestet mit 4 Geschwindigkeiten (50, 100, 200, und Max. 340 rpm) sieht das so aus (ein Motor wieder mit Kette, der andere frei drehend):</div>
</div>
<div class="paragraph">
<p>Man sieht sehr schön, dass der Regler es eigentlich ganz gut schafft, bei beiden Motoren die geforderten Drehzahlen zu erreichen. Nur in der höchsten Stufe schafft es der Motor mit Kette nicht ganz die geforderte Drehzahl zu erreichen, denn er läuft schon konstant am obersten Limit (Duty Cycle 100%). Aufgrund der unterschiedlichen Reibwiderstände muss der Motor mit der Ketten (hellblau) stets einen deutlich höheren Duty Cycle fahren, um die Drehzahl zu erreichen.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die Implementierung des PID-Reglers ist unvollständig - eigentlich funktioniert nur der P-Teil des Reglers. Aber im Rahmen der möglichen Genauigkeiten passt das soweit.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_programmierung_des_rangers_ohne_makeblock_bibliothek_mit_robuster_entfernungsmessung">8.5. Programmierung des Rangers OHNE Makeblock-Bibliothek mit robuster Entfernungsmessung</h3>
<div class="paragraph">
<p>Die Makeblock-Bibliothek und die Klasse <code>MeEncoderOnBoard</code> sind für präzise Steuerungen des Roboters nicht wirklich optimal, da das Regelsignal (Geschwindigkeit) durch das stets automatische Rücksetzen beim Auswerten ziemlich zappelt. Wenn man mehr Kontrolle über die Regelung haben möchte, kommt man an einer eigenen Behandlung der Encoder nicht drum herum.</p>
</div>
<div class="paragraph">
<p>Hier ist ein Beispielcode, der fast das Gleiche macht, wie das Listing in <a href="#sec:motor:encodertest">Abschnitt 8.3.1</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Testprogramm für die Ansteuerung der DC Motoren OHNE Makeblock Bibliothek</span>

<span class="cp">#define PWMA  11 // Motor A/Links
#define DIRA1 49
#define DIRA2 48
#define PWMB  10 // Motor B/Rights
#define DIRB1 47
#define DIRB2 46
</span>
<span class="cp">#define ENCODER1_PIN1 19
#define ENCODER1_PIN2 42
</span>
<span class="cp">#define ENCODER2_PIN1 18
#define ENCODER2_PIN2 43
</span>
<span class="cp">#define RPM2PWMFACTOR 1.33
#define PULSESPERREVOLUTION 353.403
</span>
<span class="k">class</span> <span class="nc">Encoder</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Encoder</span><span class="p">(</span><span class="kt">int</span> <span class="n">pin1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pin2</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_pin1</span><span class="p">(</span><span class="n">pin1</span><span class="p">),</span> <span class="n">m_pin2</span><span class="p">(</span><span class="n">pin2</span><span class="p">),</span> <span class="n">m_pulses</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_speedMillis</span> <span class="o">=</span> <span class="n">millis</span><span class="p">();</span> <span class="p">}</span>

  <span class="kt">float</span> <span class="n">rpmPerMinute</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deltaT</span> <span class="o">=</span> <span class="n">millis</span><span class="p">()</span> <span class="o">-</span> <span class="n">m_speedMillis</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">pulsePerSecond</span> <span class="o">=</span> <span class="n">m_pulses</span><span class="o">*</span><span class="mf">1000.0</span><span class="o">/</span><span class="n">deltaT</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">rpmPerMinute</span> <span class="o">=</span> <span class="n">pulsePerSecond</span><span class="o">*</span><span class="mi">60</span><span class="o">/</span><span class="n">PULSESPERREVOLUTION</span><span class="p">;</span> <span class="c1">// 353.403 Pulse pro Umdrehung</span>
    <span class="k">return</span> <span class="n">rpmPerMinute</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">resetPulses</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">m_speedMillis</span> <span class="o">=</span> <span class="n">millis</span><span class="p">();</span>
    <span class="n">m_pulses</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">m_pin1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">m_pin2</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">m_pulses</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">m_speedMillis</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Encoder</span> <span class="n">encoder1</span><span class="p">(</span><span class="n">ENCODER1_PIN1</span><span class="p">,</span> <span class="n">ENCODER1_PIN2</span><span class="p">);</span>
<span class="n">Encoder</span> <span class="n">encoder2</span><span class="p">(</span><span class="n">ENCODER2_PIN1</span><span class="p">,</span> <span class="n">ENCODER2_PIN2</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">startMillis</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lastOutputMillis</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">targetPWM</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">buffIndex</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>


<span class="c1">// Für präzise Messung der Geschwindigkeit (und damit Position) der Motoren</span>
<span class="c1">// werden die Pulse via Interruptfunktionen hoch/runtergezählt.</span>
<span class="c1">// Jedes Mal, wenn der Interrupt-Pin eines Encoders von LOW auf HIGH wechselt (RISING),</span>
<span class="c1">// wird die jeweilige isr_process_encoderX() Funktion aufgerufen und zählt einen</span>
<span class="c1">// Pulse hoch.</span>

<span class="c1">// Interruptfunktion für Encoder 1</span>
<span class="kt">void</span> <span class="n">isr_process_encoder1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">digitalRead</span><span class="p">(</span><span class="n">encoder1</span><span class="p">.</span><span class="n">m_pin2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="o">--</span><span class="n">encoder1</span><span class="p">.</span><span class="n">m_pulses</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="o">++</span><span class="n">encoder1</span><span class="p">.</span><span class="n">m_pulses</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Interruptfunktion für Encoder 2</span>
<span class="kt">void</span> <span class="n">isr_process_encoder2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">digitalRead</span><span class="p">(</span><span class="n">encoder2</span><span class="p">.</span><span class="n">m_pin2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="o">--</span><span class="n">encoder2</span><span class="p">.</span><span class="n">m_pulses</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="o">++</span><span class="n">encoder2</span><span class="p">.</span><span class="n">m_pulses</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// PWM und Richtungspins setzen</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">PWMA</span><span class="p">,</span>  <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">DIRA1</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">DIRA2</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">PWMB</span><span class="p">,</span>  <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">DIRB1</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">DIRB1</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>

<span class="c1">// WICHTIG: INPUTs mit PullUp Widerständen!</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">ENCODER1_PIN1</span><span class="p">,</span> <span class="n">INPUT_PULLUP</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">ENCODER1_PIN1</span><span class="p">,</span> <span class="n">INPUT_PULLUP</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">ENCODER2_PIN2</span><span class="p">,</span> <span class="n">INPUT_PULLUP</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">ENCODER2_PIN2</span><span class="p">,</span> <span class="n">INPUT_PULLUP</span><span class="p">);</span>

  <span class="c1">// kurze Wartephase zur Initialisierung</span>
  <span class="n">delay</span> <span class="p">(</span><span class="mi">20</span><span class="p">);</span>

  <span class="c1">// Festlegen der Interruptfunktionen für das Messen/Zählen der Bewegung</span>
  <span class="n">attachInterrupt</span><span class="p">(</span><span class="n">digitalPinToInterrupt</span><span class="p">(</span><span class="n">ENCODER1_PIN1</span><span class="p">),</span> <span class="n">isr_process_encoder1</span><span class="p">,</span> <span class="n">RISING</span><span class="p">);</span>
  <span class="n">attachInterrupt</span><span class="p">(</span><span class="n">digitalPinToInterrupt</span><span class="p">(</span><span class="n">ENCODER2_PIN1</span><span class="p">),</span> <span class="n">isr_process_encoder2</span><span class="p">,</span> <span class="n">RISING</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>

  <span class="c1">// Interne Timer der PWM auf 8KHz programmieren</span>
  <span class="n">TCCR1A</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM10</span><span class="p">);</span>
  <span class="n">TCCR1B</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">CS11</span><span class="p">)</span> <span class="o">|</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM12</span><span class="p">);</span>

  <span class="n">TCCR2A</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM21</span><span class="p">)</span> <span class="o">|</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM20</span><span class="p">);</span>
  <span class="n">TCCR2B</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">CS21</span><span class="p">);</span>

  <span class="c1">// Variable für gelegentliche Ausgaben auf die serielle Schnittstelle</span>
  <span class="n">lastOutputMillis</span> <span class="o">=</span> <span class="n">startMillis</span> <span class="o">=</span> <span class="n">millis</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">leftMotorSpeed</span><span class="p">(</span><span class="kt">int</span> <span class="n">targetPWM</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">targetPWM</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">analogWrite</span> <span class="p">(</span><span class="n">PWMA</span><span class="p">,</span>  <span class="n">targetPWM</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRA1</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRA2</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">analogWrite</span> <span class="p">(</span><span class="n">PWMA</span><span class="p">,</span>  <span class="o">-</span><span class="n">targetPWM</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRA1</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRA2</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">rightMotorSpeed</span><span class="p">(</span><span class="kt">int</span> <span class="n">targetPWM</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">targetPWM</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">analogWrite</span> <span class="p">(</span><span class="n">PWMB</span><span class="p">,</span>  <span class="n">targetPWM</span><span class="p">);</span>
      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRB1</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRB2</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">analogWrite</span> <span class="p">(</span><span class="n">PWMB</span><span class="p">,</span>  <span class="o">-</span><span class="n">targetPWM</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRB1</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRB2</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// eine maximal 3-stellige Zahl von der seriellen Schnittstelle lesen</span>
  <span class="kt">char</span> <span class="n">lastChar</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">Serial</span><span class="p">.</span><span class="n">available</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">buffIndex</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lastChar</span> <span class="o">=</span> <span class="n">Serial</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
    <span class="c1">// Falls noch weniger &lt; 3 Zeichen und kein Zeilenende, Zeichen in Puffer schieben</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lastChar</span> <span class="o">!=</span> <span class="sc">'\n'</span> <span class="o">&amp;&amp;</span> <span class="n">buffIndex</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
      <span class="n">buf</span><span class="p">[</span><span class="n">buffIndex</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">lastChar</span><span class="p">;</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Zeichenkette in Puffer mit \0 beenden</span>
      <span class="n">buf</span><span class="p">[</span><span class="n">buffIndex</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
      <span class="c1">// Text in Zahl umwandeln</span>
      <span class="n">targetPWM</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
      <span class="c1">// auf Wertebereich -255 bis 255 begrenzen</span>
      <span class="n">targetPWM</span> <span class="o">=</span> <span class="n">constrain</span><span class="p">(</span><span class="n">targetPWM</span><span class="p">,</span> <span class="o">-</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>
      <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"targetspeed = "</span><span class="p">);</span>
      <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">targetPWM</span><span class="p">);</span>
      <span class="c1">// Motorgeschwindigkeiten anpassen</span>
      <span class="n">leftMotorSpeed</span><span class="p">(</span><span class="n">targetPWM</span><span class="p">);</span>
      <span class="n">rightMotorSpeed</span><span class="p">(</span><span class="n">targetPWM</span><span class="p">);</span>
      <span class="c1">// den Counter zurücksetzen</span>
      <span class="n">encoder1</span><span class="p">.</span><span class="n">resetPulses</span><span class="p">();</span>
      <span class="n">encoder2</span><span class="p">.</span><span class="n">resetPulses</span><span class="p">();</span>
      <span class="n">buffIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// alle 100 Millisekunden die Geschwindigkeit ausgeben</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">millis</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">lastOutputMillis</span> <span class="o">+</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lastOutputMillis</span> <span class="o">=</span> <span class="n">millis</span><span class="p">();</span>
    <span class="c1">// Ausgabe: Zeit [s]  \t Ziel-PWM \t Speed 1 [rpm] \t Speed 2 [rpm]</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">((</span><span class="n">millis</span><span class="p">()</span> <span class="o">-</span> <span class="n">startMillis</span><span class="p">)</span><span class="o">*</span><span class="mf">0.001</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">"</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">targetPWM</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">"</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="o">-</span><span class="n">encoder1</span><span class="p">.</span><span class="n">rpmPerMinute</span><span class="p">());</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">"</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">encoder2</span><span class="p">.</span><span class="n">rpmPerMinute</span><span class="p">());</span>
    <span class="c1">// den Counter zurücksetzen</span>
    <span class="n">encoder1</span><span class="p">.</span><span class="n">resetPulses</span><span class="p">();</span>
    <span class="n">encoder2</span><span class="p">.</span><span class="n">resetPulses</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Man kann im SerialMonitor or SerialPlotter nun die Sollleistung in PWM (-255..255) angeben.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_abschließende_bemerkungen">9. Abschließende Bemerkungen</h2>
<div class="sectionbody">

</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.0 (17.02.2025)<br>
Last updated 2025-02-17 22:00:40 +0100
</div>
</div>
</body>
</html>