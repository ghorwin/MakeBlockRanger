<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<meta name="author" content="Andreas Nicolai">
<title>Makeblock mBot Ranger: Eine Anleitung zur Programmierung des Roboterbausatzes mit der ArduinoIDE</title>
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */

@import url(../css/asciidoctor.css); /* Default asciidoc style framework - important */

/* roboto-condensed-regular - latin */
@font-face {
  font-family: 'Roboto Condensed';
  font-style: normal;
  font-weight: 400;
  src: url('../fonts/roboto-condensed-v25-latin-regular.eot'); /* IE9 Compat Modes */
  src: local(''),
       url('../fonts/roboto-condensed-v25-latin-regular.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('../fonts/roboto-condensed-v25-latin-regular.woff2') format('woff2'), /* Super Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-regular.woff') format('woff'), /* Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-regular.ttf') format('truetype'), /* Safari, Android, iOS */
       url('../fonts/roboto-condensed-v25-latin-regular.svg#RobotoCondensed') format('svg'); /* Legacy iOS */
}
/* roboto-condensed-italic - latin */
@font-face {
  font-family: 'Roboto Condensed';
  font-style: italic;
  font-weight: 400;
  src: url('../fonts/roboto-condensed-v25-latin-italic.eot'); /* IE9 Compat Modes */
  src: local(''),
       url('../fonts/roboto-condensed-v25-latin-italic.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('../fonts/roboto-condensed-v25-latin-italic.woff2') format('woff2'), /* Super Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-italic.woff') format('woff'), /* Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-italic.ttf') format('truetype'), /* Safari, Android, iOS */
       url('../fonts/roboto-condensed-v25-latin-italic.svg#RobotoCondensed') format('svg'); /* Legacy iOS */
}
/* roboto-condensed-700 - latin */
@font-face {
  font-family: 'Roboto Condensed';
  font-style: normal;
  font-weight: 700;
  src: url('../fonts/roboto-condensed-v25-latin-700.eot'); /* IE9 Compat Modes */
  src: local(''),
       url('../fonts/roboto-condensed-v25-latin-700.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('../fonts/roboto-condensed-v25-latin-700.woff2') format('woff2'), /* Super Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-700.woff') format('woff'), /* Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-700.ttf') format('truetype'), /* Safari, Android, iOS */
       url('../fonts/roboto-condensed-v25-latin-700.svg#RobotoCondensed') format('svg'); /* Legacy iOS */
}
/* roboto-condensed-700italic - latin */
@font-face {
  font-family: 'Roboto Condensed';
  font-style: italic;
  font-weight: 700;
  src: url('../fonts/roboto-condensed-v25-latin-700italic.eot'); /* IE9 Compat Modes */
  src: local(''),
       url('../fonts/roboto-condensed-v25-latin-700italic.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('../fonts/roboto-condensed-v25-latin-700italic.woff2') format('woff2'), /* Super Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-700italic.woff') format('woff'), /* Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-700italic.ttf') format('truetype'), /* Safari, Android, iOS */
       url('../fonts/roboto-condensed-v25-latin-700italic.svg#RobotoCondensed') format('svg'); /* Legacy iOS */
}

/* CUSTOMISATIONS */
/* Change the values in root for quick customisation. If you want even more fine grain... venture further. */

:root{
--maincolor:#FFFFFF;
--primarycolor:#a90e22;
--secondarycolor:#9f1d0b;
--tertiarycolor: #ededed;
--sidebarbackground:#CCC;
--linkcolor:#b71c1c;
--linkcoloralternate:#f44336;
--white:#FFFFFF;
--black:#000000;
}

/* Text styles */
body{font-family: "Roboto Condensed",sans-serif;}

h1,h2{color:var(--primarycolor) !important;font-family:"Roboto Condensed",sans-serif;}
h3,h4,h5,h6{color:var(--secondarycolor);font-family: "Roboto Condensed",sans-serif; }
.title{color:(--primarycolor) !important;font-family:"Roboto Condensed",sans-serif;font-style: normal; font-weight: normal;}
p{font-family: "Roboto Condensed",sans-serif ! important}
#toc.toc2 a{font-family:"Roboto Condensed",sans-serif;}
/*#toc.toc2 a:link{color:(--linkcolor) !important}
a:visited {color: #ffdbad;}
a.bare:visited {color: #204f83;}
a:hover {color: #317ed4;}
#toc.toc2 a:hover {color: #f1b464;}*/
/* code{background-color: var(--secondarycolor) !important;color:var(--white)} */
code,kbd,pre,samp{font-family:"Consolas","Droid Sans Mono","DejaVu Sans Mono",monospace;monospace;font-size:1em}

/* Table styles */
th{background-color: var(--tertiarycolor);color:var(--black) !important;}

#toctitle{color:var(--primarycolor);font-family: "Roboto Condensed",sans-serif;font-size: 1.6875em;}
#toc.toc2{background-color:#f4f8fd;}
/*#toc.toc2{background-color:#2C001E;color:white;}
#toc.toc2.a{color:white;}
*/

/* Responsiveness fixes */
video {
  max-width: 100%;
}

@media all and (max-width: 600px) {
table {
  width: 55vw!important;
  font-size: 3vw;
}

</style>
<link rel="stylesheet" href="../css/font-awesome.css">
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sa {
  color: #000000;
  font-weight: bold;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Makeblock mBot Ranger: Eine Anleitung zur Programmierung des Roboterbausatzes mit der ArduinoIDE</h1>
<div class="details">
<span id="author" class="author">Andreas Nicolai</span><br>
<span id="email" class="email"><a href="mailto:andreas.nicolai@gmx.net">andreas.nicolai@gmx.net</a></span><br>
<span id="revnumber">version 1.0 (11.01.2025)</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Inhaltsverzeichnis</div>
<ul class="sectlevel1">
<li><a href="#_einleitung">1. Einleitung</a>
<ul class="sectlevel2">
<li><a href="#_überblick_über_den_roboterbausatz">1.1. Überblick über den Roboterbausatz</a></li>
<li><a href="#_informationsquellen">1.2. Informationsquellen</a></li>
</ul>
</li>
<li><a href="#_aufspielenaktualisieren_der_firmware_und_ein_erstes_testprogramm">2. Aufspielen/Aktualisieren der Firmware und ein erstes Testprogramm</a>
<ul class="sectlevel2">
<li><a href="#_verbindung_des_auriga_boards_mit_den_linux_pc">2.1. Verbindung des Auriga-Boards mit den Linux-PC</a>
<ul class="sectlevel3">
<li><a href="#_behebung_von_brttly_problemen">2.1.1. Behebung von brttly Problemen</a></li>
</ul>
</li>
<li><a href="#_firmware_update_neu_installieren">2.2. Firmware-Update / Neu-Installieren</a>
<ul class="sectlevel3">
<li><a href="#_firmware_mit_mblock_aktualisierenzurücksetzen">2.2.1. Firmware mit mBlock aktualisieren/zurücksetzen</a></li>
</ul>
</li>
<li><a href="#_makeblock_libraries_über_arduino_ide_bibliotheksverwaltung_installieren">2.3. Makeblock-Libraries über Arduino-IDE Bibliotheksverwaltung installieren</a>
<ul class="sectlevel3">
<li><a href="#_installation_via_bibliotheksmanager_empfohlen">2.3.1. Installation via Bibliotheksmanager (empfohlen)</a></li>
<li><a href="#_manuelle_installation">2.3.2. Manuelle Installation</a></li>
</ul>
</li>
<li><a href="#_firmware_update_installieren_zurücksetzen">2.4. Firmware Update installieren / zurücksetzen</a></li>
</ul>
</li>
<li><a href="#sec:basics">3. Die Grundlagen der Auriga-Programmierung</a>
<ul class="sectlevel2">
<li><a href="#_kleines_testbeispiel">3.1. Kleines Testbeispiel</a></li>
</ul>
</li>
<li><a href="#_onboard_leds_und_rgb_ring">4. OnBoard LEDs und RGB Ring</a>
<ul class="sectlevel2">
<li><a href="#_allgemeines">4.1. Allgemeines</a></li>
<li><a href="#_standard_built_in_led">4.2. Standard built-in LED</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm">4.2.1. Beispielprogramm</a></li>
</ul>
</li>
<li><a href="#_onboard_leds_kommunikationsmodul">4.3. OnBoard LEDs (Kommunikationsmodul)</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm_2">4.3.1. Beispielprogramm</a></li>
</ul>
</li>
<li><a href="#_12er_rgb_led_ring">4.4. 12er RGB LED Ring</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm_3">4.4.1. Beispielprogramm</a></li>
<li><a href="#_die_wichtigsten_funktionen_der_mergbled_klasse">4.4.2. Die wichtigsten Funktionen der MeRGBLed Klasse</a></li>
<li><a href="#_programmierideen">4.4.3. Programmierideen</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_onboard_sensoren_licht_schall_temperature_gyroscop">5. OnBoard Sensoren (Licht, Schall, Temperature, Gyroscop)</a>
<ul class="sectlevel2">
<li><a href="#_lautstärkeschall">5.1. Lautstärke/Schall</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm_4">5.1.1. Beispielprogramm</a></li>
</ul>
</li>
<li><a href="#_lichthelligkeit">5.2. Licht/Helligkeit</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm_5">5.2.1. Beispielprogramm</a></li>
</ul>
</li>
<li><a href="#_temperatur">5.3. Temperatur</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm_6">5.3.1. Beispielprogramm</a></li>
</ul>
</li>
<li><a href="#_gyroskop">5.4. Gyroskop</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm_7">5.4.1. Beispielprogramm</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_töne_mit_dem_passiven_buzzer_auf_dem_board">6. Töne mit dem passiven Buzzer auf dem Board</a>
<ul class="sectlevel2">
<li><a href="#_allgemeines_2">6.1. Allgemeines</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm_8">6.1.1. Beispielprogramm</a></li>
</ul>
</li>
<li><a href="#_verwendung_der_makeblock_klasse_mebuzzer">6.2. Verwendung der Makeblock Klasse MeBuzzer</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm_9">6.2.1. Beispielprogramm</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_motorsteuerung">7. Motorsteuerung</a>
<ul class="sectlevel2">
<li><a href="#_allgemeines_3">7.1. Allgemeines</a></li>
<li><a href="#_direkte_ansteuerung_über_pwm_und_digitale_pins">7.2. Direkte Ansteuerung über PWM und digitale Pins</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm_direkte_ansteuerung">7.2.1. Beispielprogramm - Direkte Ansteuerung</a></li>
</ul>
</li>
<li><a href="#_ansteuerung_über_encoder_klasse_der_bibliothek">7.3. Ansteuerung über Encoder-Klasse der Bibliothek</a>
<ul class="sectlevel3">
<li><a href="#_beispielprogramm_ansteuerung_mittels_bibliotheksfunktion">7.3.1. Beispielprogramm - Ansteuerung mittels Bibliotheksfunktion</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_abschließende_bemerkungen">8. Abschließende Bemerkungen</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_einleitung">1. Einleitung</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Dieser Makeblock mBot Ranger Programmierkurs baut auf vorhandenen Grundlagen zur Arduino-Programmierung auf. Man sollte also schon die Arduino IDE kennen und natürlich auch Grundlagen der C-Programmiersprache beherrschen. In diesem Tutorial bzw. Robotik-Kurs wird gezeigt, wie man den mBot Ranger Bausatz mittels der Arduino-IDE und der C bzw. C++ Programmiersprache programmiert (wenn man also die Stufe der Block-Programmierung überwunden hat).</p>
</div>
<div class="paragraph">
<p>Es geht also um folgenden Robotor</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/makeblock-mbot-ranger.jpg" alt="makeblock mbot ranger" width="400">
</div>
</div>
<div class="paragraph">
<p>bzw. die darin verbaute Auriga-Platine mit dem Arduino-Prozessor.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In diesem Tutorial wird Linux (konkret Ubuntu) verwendet. Linux bringt die Treiber für den ch341-Chip bereits mit, während man unter Windows hier noch die Treiber installieren muss. Bei Gelegenheit würde ich</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Der <em>MakeBlock Ranger</em>, oder besser gesagt das Gehirn davon, das Auriga Board mit dem Arduino Mega 2560 Prozessor wird angeschlossen und erklärt, wie man die Entwicklungsbibliotheken einrichtet und die Firmware aktualisiert bzw. nach dem Aufspielen eigener Programme wieder zurücksetzt. Dieser Text erklärt auch ein paar Hintergründe und wie die RJ25 Ports mit den Arduino-Pins verbunden sind und gibt allgemein erstmal eine Orientierung, wie das Ganze so funktioniert.</p>
</div>
<div class="paragraph">
<p>Ein kleines Minibeispiel zum Austesten der Programmierumgebung und Aufspielen eines Programms auf den Robotor schließt das Kapitel ab.</p>
</div>
<div class="sect2">
<h3 id="_überblick_über_den_roboterbausatz">1.1. Überblick über den Roboterbausatz</h3>
<div class="paragraph">
<p>Als Roboterbausatz wird der Makeblock mBot Ranger verwendet. Es gibt noch andere Makeblock Bausätze. Die Pin/Port-Belegung ist dann etwas anders und es gibt andere Sensoren, aber im Großen und Ganzen funktioniert das alles sehr ähnlich wie bei dem hier beschriebenen mBot Ranger.</p>
</div>
<div class="paragraph">
<p>Mit dem Bausatz lassen sich 3 verschiedene Modelle bauen (und mit etwas Kreativität noch weitere):</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/makeblock-mbot-ranger.jpg" alt="makeblock mbot ranger" width="300">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/makeblock-mbot-raptor.jpg" alt="makeblock mbot raptor" width="300">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/makeblock-mbot-bird.jpg" alt="makeblock mbot bird" width="300">
</div>
</div>
<div class="paragraph">
<div class="title">Mögliche Modelle, welche man mit dem Bausatz bauen kann</div>
<p>Der Bausatz verwendet ein Auriga Board, mit einem Arduino Mega 2560 Prozessor. Das Auriga-Board ist die Weiterentwicklung des Orion-Boards (welches bei früheren mBot Bausätzen verwendet wurde) und kann einiges mehr.</p>
</div>
<div class="paragraph">
<p>Hier ist eine Funktions-/Ausstattungsbeschreibung (basierend auf der Produktbeschreibung aus
<a href="https://shop.technik-lpe.de/steuerboards/872-auriga-steuerboard-6928819504967.html">shop.technik-lpe.de</a>:</p>
</div>
<div class="paragraph">
<p>Der <strong>Auriga</strong> ist eine einfach zu bedienende Hauptsteuerplatine, die speziell für den MINT-Unterricht entwickelt wurde. Basierend auf dem Arduino ATmega 2560 hat der Auriga ein paar mehr Möglichkeiten, Sensoren oder Aktoren anschließen zu können. Hier ist ein kleiner Überblick:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Onboard-Gyroskop, Tonsensor, passiver Summer und Temperatursensor, 2 Lichtsensoren</p>
</li>
<li>
<p>Unterstützt DC-Motoren, Schrittmotoren, Servoregler, Smart Servos, Encoder-Motoren, etc.</p>
</li>
<li>
<p>Kann zwei Encoder-Motoren ansteuern und unterstützt Überstromschutz für 4A (sofort).</p>
</li>
<li>
<p>Unterstützt Bluetooth und drahtlose Bluetooth-Upgrade-Firmware Bluetooth-Dongle</p>
</li>
<li>
<p>Blaue LED</p>
</li>
<li>
<p>WS1282 RGB LED ring</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/auriga_schaubild.jpg" alt="auriga schaubild" width="500">
</div>
<div class="title">Abbildung 1. Schaubild der Aurigaplatine mit verbauten Sensoren</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/farbcodierung_auriga.jpg" alt="farbcodierung auriga" width="150">
</div>
<div class="title">Abbildung 2. Farbkodierung der Anschlüsse (Details dazu im Kapitel zu den RJ25 Ports)</div>
</div>
<div class="ulist">
<ul>
<li>
<p>PORT1 - PORT4 unterstützen einen kontinuierlichen 3,5A-Ausgang (max. 5A)</p>
</li>
<li>
<p>PORT5 - PORT10 haben einen Kurzschluss- und Überstromschutz für 3A</p>
</li>
<li>
<p>PORT5 - PORT10 unterstützen kontinuierlich 5V DC und 4A Ausgang (max. 3A)</p>
</li>
<li>
<p>PORT1 - PORT4 haben einen Kurzschluss- und Überstromschutz für 3,5A</p>
</li>
<li>
<p>USB-Anschluss mit antistatischem Schutz (Akku wird darüber nicht geladen)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_informationsquellen">1.2. Informationsquellen</h3>
<div class="paragraph">
<p>Die offizielle Dokumentation des Roboterbausatzes schweigt sich über die Internas und Programmierung der Platine ziemlich aus. Daher basiert diese Anleitung auf Reverse-Engineering, Literaturrecherche im Internet und Sichtung vieler Forenbeiträge.</p>
</div>
<div class="paragraph">
<p>Viele nachfolgend und in den anderen Teilen beschriebene Details habe ich aus dem englischsprachigen Text von <em>Gosse Adema</em> (<a href="https://www.instructables.com/Advanced-Makeblock-Sensors-DIY">https://www.instructables.com/Advanced-Makeblock-Sensors-DIY</a>) gefunden.</p>
</div>
<div class="paragraph">
<p>Hier sind noch einige Dokumente, die ich zusammengetragen habe:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="downloads/Makeblock_Leaflet_mBot-Ranger_2018Q3_V1-1-1_View.pdf">MakeBlock Ranger Flyer</a></p>
</li>
<li>
<p><a href="downloads/mBot-Ranger_Blue_Instruction_Book.pdf">mBot Ranger (Bau-)Anleitung</a></p>
</li>
<li>
<p><a href="downloads/getting_started_with_mBlock.pdf">mBlock Entwicklungsumgebung - Getting Started</a></p>
</li>
<li>
<p><a href="downloads/MeAuriga_Schaltplan.pdf">Auriga Schaltplan</a></p>
</li>
<li>
<p><a href="downloads/MeAuriga_Pinout.pdf">Auriga Pinout</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_aufspielenaktualisieren_der_firmware_und_ein_erstes_testprogramm">2. Aufspielen/Aktualisieren der Firmware und ein erstes Testprogramm</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_verbindung_des_auriga_boards_mit_den_linux_pc">2.1. Verbindung des Auriga-Boards mit den Linux-PC</h3>
<div class="paragraph">
<p>Der erste Schritt zur Programmierung des Auriga Boards, ist es eine serielle Verbindung mit dem Board aufzubauen. Dazu verbindet man das Board via USB-Kabel mit dem PC.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wie üblich unter Linux muss der Nutzer zum Zugriff auf COM Ports der Gruppe <em>dialout</em> zugehören.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>sudo dmesg</code> sollte dann ausgeben, mit welchem COM-Port das Bord verbunden ist.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>&gt; sudo dmesg
[ 1588.506008] usb 3-2: new full-speed USB device number 4 using xhci_hcd
[ 1588.677924] usb 3-2: New USB device found, idVendor=1a86, idProduct=7523, bcdDevice= 2.64
[ 1588.677942] usb 3-2: New USB device strings: Mfr=0, Product=2, SerialNumber=0
[ 1588.677949] usb 3-2: Product: USB Serial
[ 1588.686988] ch341 3-2:1.0: ch341-uart converter detected
[ 1588.701256] usb 3-2: ch341-uart converter now attached to ttyUSB0</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Windows/Mac-Nutzer müssen erst den ch341-Treiber installieren (Internetsuche hilft).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_behebung_von_brttly_problemen">2.1.1. Behebung von brttly Problemen</h4>
<div class="paragraph">
<p>Bei Ubuntu 22.04 und einigen neueren Ubuntu Versionen wird beim Anschließend des Boards an den USB-Port die Verbindung mit <code>/dev/ttyUSB0</code> kurz hergestellt und gleich wieder unterbrochen (ab Ubuntu 24.04 scheint das aber kein Problem mehr zu sein).
Ausgabe von <code>sudo dmesg</code> ist ähnlich wie:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>[  284.973894] usb 3-4.2: ch34x converter now attached to ttyUSB0
[  285.019333] usb 3-4.2: usbfs: interface 0 claimed by ch34x while 'brltty' sets config #1
[  285.019883] ch34x ttyUSB0: ch34x converter now disconnected from ttyUSB0
[  285.019895] ch34x 3-4.2:1.0: device disconnected</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das Problem liegt daran, dass der <code>brltty</code>-Dienst (braille display driver/Treiber für ein <a href="https://de.wikipedia.org/wiki/Braillezeile">Brailledisplay</a>) dazwischenfunkt.</p>
</div>
<div class="paragraph">
<p>Den brltty Dienst (Assistenzdienst) schaltet man wie folgt ab:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code># Systemdienste deaktivieren
sudo systemctl mask brltty.path
sudo systemctl mask brltty.service

# udev Regeln ausschalten
for f in /usr/lib/udev/rules.d/*brltty*.rules; do
    sudo ln -s /dev/null "/etc/udev/rules.d/$(basename "$f")"
done
# Dienste neu laden
sudo udevadm control --reload-rules</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nun kann man das Board verbinden und sollte die Ausgabe oben im vorangehenden Abschnitt sehen.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_firmware_update_neu_installieren">2.2. Firmware-Update / Neu-Installieren</h3>
<div class="paragraph">
<p>Der Makeblock Ranger bzw. das Board und der Prozessor werden mit einer vorinstallierten <em>Firmware</em> geliefert. Das ist nichts anderes als ein Arduino-Programm. Dieses Programm enthält die Basisfunktionalität (wie im Handbuch beschrieben), einschließlich der Bluetooth Kommunikation mit dem SmartPhone.</p>
</div>
<div class="paragraph">
<p>Dieses Programm (also die <em>Firmware</em>), ist im Quelltext verfügbar. Den kann man sich herunterladen (siehe unten) und nach Belieben anpassen und verändern. Das ist auch einer der Gründe, warum ich die MakeBlock Roboterbausätze ziemlich cool finde.  Außerdem kann man in der Firmware jede Menge abgucken.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wenn man nach dem Hochladen eigener Programme mal wieder die Originalfunktionalität haben will, spielt man einfach dieses Firmware-Programm hoch und hat wieder den Auslieferungszustand. Man kann also nichts kaputt machen :-)</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die originale Firmware stellt auch die Funktionalität für die "Live"-Tests in der mBlock-Umgebung (z.B. zum Sensor-Auslesen) bereit. Sobald man ein anderes Programm hochgeladen hat, funktioniert diese "Live"-Funktionalität nicht mehr. Wenn man also wieder mit mBlock arbeiten will, und dort die "Live-"Test Funktionalität braucht, lädt man einfach dei Firmware wieder hoch und mBlock funktioniert wieder wie bisher.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wie wir später sehen werden, kann man aber über den <em>Serial Monitor</em> der Arduino-IDE alle Sensorwerte bequem ausgeben und brauch die mBlock Oberfläche gar nicht mehr.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_firmware_mit_mblock_aktualisierenzurücksetzen">2.2.1. Firmware mit mBlock aktualisieren/zurücksetzen</h4>
<div class="paragraph">
<p>Die Firmware kann aber auch mit der mBlock Entwicklungsumgebung installiert werden.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In der aktuellen mBlock Webversion scheint der Download der Firmware allerdings nicht mehr robust zu funktionieren. Auch funktionieren die Treiber für Linux nicht mehr und auch sonst scheint die Software nicht (mehr) richtig zu funktionieren. Außerdem ist die original-Firmware seit 2020 nicht mehr weiterentwickelt worden. Daher sollte die Firmware besser wie nachfolgend beschrieben mit der Arduino-IDE aktualisiert werden.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_makeblock_libraries_über_arduino_ide_bibliotheksverwaltung_installieren">2.3. Makeblock-Libraries über Arduino-IDE Bibliotheksverwaltung installieren</h3>
<div class="paragraph">
<p>Für das Compilieren der Firmware sind aber noch die Makeblock-Bibliotheken notwendig. Dafür gibt es zwei Methoden:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Installation mittels Arduino-IDE Bibliotheksverwaltung (empfohlen!)</p>
</li>
<li>
<p>Manuelle Installation der Bibliothek, oder</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_installation_via_bibliotheksmanager_empfohlen">2.3.1. Installation via Bibliotheksmanager (empfohlen)</h4>
<div class="paragraph">
<p>Die Installation der makeblock-Bibliothek erfolgt analog zu anderen Arduino-Bibliotheken.</p>
</div>
<div class="paragraph">
<p>Abgesehen von der Original-Bibliothek gibt es inzwischen verschiedene Forks mit aktualisierten Quelltexten, die einige Fehler beheben. In der aktuellen Version der Arduino-IDE ist eine solche aktualisierte Version auch direkt über den Bibliotheksmanager verfügbar (Bibliotheksverwaltung öffnen und im Filter <em>makeblock</em> eingeben):</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/arduino-ide-makeblock-library-install.png" alt="arduino ide makeblock library install">
</div>
<div class="title">Abbildung 3. Bibliotheksmanager in der Arduino-IDE und ausgewählt MakeBlock Dive Updated Bibliothek</div>
</div>
</div>
<div class="sect3">
<h4 id="_manuelle_installation">2.3.2. Manuelle Installation</h4>
<div class="paragraph">
<p>Alternativ gibt es auch hier die Möglichkeit, die Bibliothek via Download des Quelltextes manuell zu installieren.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>So kann man aktualisierte Versionen einer Bibliothek installieren, ohne auf die offiziellen Bibliotheksquellen zu warten.
Außerdem kann man so eigene Anpassungen in der Bibliothek (so man das braucht) integrieren.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Dazu lädt man den Quelltext herunter, z.B. den  <a href="https://github.com/nbourre/Makeblock-Libraries">MakeBlock Drive Updated Quelltext</a>. Die heruntergeladene Bibliothek kann in der Arduino-IDE via <em>Sketch&#8594;Bibliothek einbinden&#8594;.ZIP-Bibliothek hinzufügen&#8230;&#8203;</em> eingebunden werden.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die offiziellen MakeBlock-Bibliotheken werden seit 2020 nicht mehr aktiv weiterentwickelt.
Das offizielle <a href="https://github.com/Makeblock-official/Makeblock-Libraries.git">Makeblock-Libraries GitHub Repository</a> enthält die originalen Quelltexte. Man kann die Bibliothek auch über den Link über folgenden Link herunterladen: <a href="https://codeload.github.com/Makeblock-official/Makeblock-Libraries/zip/master">Makeblock-Libraries - ZIP</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_firmware_update_installieren_zurücksetzen">2.4. Firmware Update installieren / zurücksetzen</h3>
<div class="paragraph">
<p>Die Makeblock Bibliothek bringt als <em>Beispiel</em>-Programm die Firmware mit. Man wählt diese über <em>Datei&#8594;Beispiele&#8594;MakeBlock Drive Updated&#8594;Firmware_For_Auriga</em> aus.</p>
</div>
<div class="paragraph">
<p>Man muss dann in der Arduino-IDE noch den Port und die CPU einstellen: hier wählt man <em>Arduino Mega or Mega 2560</em> aus.</p>
</div>
<div class="paragraph">
<p>Dann kann man das Firmware-Programm übersetzen und hochladen. So kann man nach dem Ausprobieren eigener Programme stets den Originalzustand zurücksetzen.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:basics">3. Die Grundlagen der Auriga-Programmierung</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Bevor man mit der Programmierung loslegt, hilft es, sich einen kleinen Überblick über die Möglichkeiten zu verschaffen. De Informationen in diesem Kapitel sind aber eher als Referenz zu verstehen, da die einzelnen Ports und Pins in den nachfolgenden Kapiteln für alle Komponenten nochmal einzeln eingeführt und erklärt werden.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/auriga_pinout.png" alt="auriga pinout">
</div>
<div class="title">Abbildung 4. Auriga Board PinOut Diagramm</div>
</div>
<div class="paragraph">
<p>Wenn man das Board mit der Makeblock-Bibliothek programmieren will, muss man die Port-Nummern kennen. Diese sind in der Makeblock-Bibliothek in der Datei <code>MeAuriga.h</code> definiert:
Jeder Makeblock-Port ist an 2 Arduino-Pins angeschlossen (siehe auch Erklärung dazu in <a href="#sec:rj25">[sec:rj25]</a>. Diese Pins werden als <em>Slot1</em> und <em>Slot2</em> bezeichnet.</p>
</div>
<div class="listingblock">
<div class="title">Auszug aus der Header-Datei <em>MeAuriga.h</em></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">MePort_Sig</span> <span class="n">mePort</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">{</span> <span class="n">NC</span><span class="p">,</span> <span class="n">NC</span> <span class="p">},</span> <span class="p">{</span>   <span class="mi">5</span><span class="p">,</span>   <span class="mi">4</span> <span class="p">},</span> <span class="p">{</span>   <span class="mi">3</span><span class="p">,</span>   <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span>   <span class="mi">7</span><span class="p">,</span>   <span class="mi">6</span> <span class="p">},</span> <span class="p">{</span>   <span class="mi">9</span><span class="p">,</span>   <span class="mi">8</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span> <span class="p">},</span> <span class="p">{</span> <span class="n">A10</span><span class="p">,</span> <span class="n">A15</span> <span class="p">},</span> <span class="p">{</span>  <span class="n">A9</span><span class="p">,</span> <span class="n">A14</span> <span class="p">},</span> <span class="p">{</span>  <span class="n">A8</span><span class="p">,</span> <span class="n">A13</span> <span class="p">},</span> <span class="p">{</span>  <span class="n">A7</span><span class="p">,</span> <span class="n">A12</span> <span class="p">},</span>
	<span class="c1">//             LIGHT2        LIGHT1        TEMP          SOUND</span>
	<span class="p">{</span> <span class="n">A6</span><span class="p">,</span><span class="n">A11</span> <span class="p">},</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">A2</span> <span class="p">},</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">A3</span> <span class="p">},</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">A0</span> <span class="p">},</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">A1</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">NC</span><span class="p">,</span> <span class="n">NC</span> <span class="p">},</span> <span class="p">{</span> <span class="n">NC</span><span class="p">,</span> <span class="n">NC</span> <span class="p">},</span>
<span class="p">};</span>

<span class="c1">// etwas umformatiert und kommentiert</span>
<span class="n">MePort_Sig</span> <span class="n">mePort</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">Port</span> <span class="mi">0</span>  <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">NC</span> <span class="p">}</span>   <span class="n">Not</span> <span class="n">connected</span>
	<span class="n">Port</span> <span class="mi">1</span>  <span class="p">{</span>   <span class="mi">5</span><span class="p">,</span>   <span class="mi">4</span> <span class="p">}</span>   <span class="n">red</span>
	<span class="n">Port</span> <span class="mi">2</span>  <span class="p">{</span>   <span class="mi">3</span><span class="p">,</span>   <span class="mi">2</span> <span class="p">}</span>   <span class="n">red</span>
	<span class="n">Port</span> <span class="mi">3</span>  <span class="p">{</span>   <span class="mi">7</span><span class="p">,</span>   <span class="mi">6</span> <span class="p">}</span>   <span class="n">red</span>
	<span class="n">Port</span> <span class="mi">4</span>  <span class="p">{</span>   <span class="mi">9</span><span class="p">,</span>   <span class="mi">8</span> <span class="p">}</span>   <span class="n">red</span>
	<span class="n">Port</span> <span class="mi">5</span>  <span class="p">{</span>  <span class="mi">16</span><span class="p">,</span>  <span class="mi">17</span> <span class="p">}</span>   <span class="n">grey</span>
	<span class="n">Port</span> <span class="mi">6</span>  <span class="p">{</span> <span class="n">A10</span><span class="p">,</span> <span class="n">A15</span> <span class="p">}</span>   <span class="n">universal</span>
	<span class="n">Port</span> <span class="mi">7</span>  <span class="p">{</span>  <span class="n">A9</span><span class="p">,</span> <span class="n">A14</span> <span class="p">}</span>   <span class="n">universal</span>
	<span class="n">Port</span> <span class="mi">8</span>  <span class="p">{</span>  <span class="n">A8</span><span class="p">,</span> <span class="n">A13</span> <span class="p">}</span>   <span class="n">universal</span>
	<span class="n">Port</span> <span class="mi">9</span>  <span class="p">{</span>  <span class="n">A7</span><span class="p">,</span> <span class="n">A12</span> <span class="p">}</span>   <span class="n">universal</span>
	<span class="n">Port</span> <span class="mi">10</span> <span class="p">{</span>  <span class="n">A6</span><span class="p">,</span> <span class="n">A11</span> <span class="p">}</span>   <span class="n">universal</span>
	<span class="n">Port</span> <span class="mi">11</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">A2</span> <span class="p">}</span>   <span class="n">light</span> <span class="n">sensor</span> <span class="mi">1</span>
	<span class="n">Port</span> <span class="mi">12</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">A3</span> <span class="p">}</span>   <span class="n">light</span> <span class="n">sensor</span> <span class="mi">2</span>
	<span class="n">Port</span> <span class="mi">13</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">A0</span> <span class="p">}</span>   <span class="n">temperature</span> <span class="n">sensor</span>
	<span class="n">Port</span> <span class="mi">14</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">A1</span> <span class="p">}</span>   <span class="n">sound</span> <span class="n">sensor</span>
	<span class="n">Port</span> <span class="mi">15</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">NC</span> <span class="p">}</span>
	<span class="n">Port</span> <span class="mi">16</span> <span class="p">{</span>  <span class="n">NC</span><span class="p">,</span>  <span class="n">NC</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Als Beispiel: der Universal Port 6 ist an den analogen Pin 10 und Analogen Pin 15 des Arduino Mikrocontrollers angeschlossen. <em>NC</em> steht für <em>Not Connected</em>. Ports 1 bis 10 sind RJ25 Ports (dazu mehr im Kapitel zu den RJ25 Anschlüssen).</p>
</div>
<div class="paragraph">
<p>Es sind aber nicht alle Komponenten über diese Ports/Pins (des Arduino 2560 Mega) anzusteuern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>Pin 44 = 12 RGB LED Ring
Pin 45 = Buzzer
Pin 13 = Blaue LED (built-in LED)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Motoren können zwar recht einfach durch die Bibliothek angesteuert werden, hier sind aber nochmal die Pins (falls man die Motoren klassisch über den Arduino ansteuern möchte, siehe Kapitel über die Motorensteuerung <a href="#sec:motoren">[sec:motoren]</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>ENA A  = pin 19
ENA B  = pin 42
PWMA   = pin 11
DIR A2 = pin 49
DIR A1 = pin 48

ENB A  = pin 18
ENB B  = pin 43
PWMB   = pin 10
DIR B1 = pin 47
DIR B2 = pin 46</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_kleines_testbeispiel">3.1. Kleines Testbeispiel</h3>
<div class="paragraph">
<p>Um das Aufspielen des Programms zu testen, kann man die eingebaute LED auf Pin 13 (wie bei jedem Arduino Board) blinken lassen. Das Programm dazu entspricht dem typischen Arduino Blink-Beispielprogramm:</p>
</div>
<div class="listingblock">
<div class="title">Triviales Beispielprogramm für ein Arduino-Board. Die eingebaute LED wird ein- und ausgeschaltet. Um sie von der rhythmisch blinkenden anderen blauen LED zu unterscheiden, lassen wir sie lang-kurz blinken.</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Eingebaute LED auf dem Arduino-Board blinken lassen</span>
<span class="c1">// Dies ist quasi das Standard-Test-Programm für die meisten Arduino-Boards</span>

<span class="kt">int</span> <span class="n">BlueLed</span> <span class="o">=</span> <span class="n">LED_BUILTIN</span><span class="p">;</span> <span class="c1">// Pin 13</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pinMode</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// lang an</span>
  <span class="n">digitalWrite</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
  <span class="n">delay</span> <span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
  <span class="c1">// kurz aus</span>
  <span class="n">digitalWrite</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
  <span class="n">delay</span> <span class="p">(</span><span class="mi">500</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die LED ist etwas schwer zu erkennen und liegt einseitig etwas verdeckt. Sehr sinnvoll ist damit ihre Ansteuerung nicht, aber zum Testen kann man das ja mal machen.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="imageblock text-left">
<div class="content">
<img src="../images/auriga-Builtin-LED.gif" alt="auriga Builtin LED">
</div>
<div class="title">Abbildung 5. Auriga Built-in LED</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_onboard_leds_und_rgb_ring">4. OnBoard LEDs und RGB Ring</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Auf dem Auriga-Board sind zahlreiche LEDs verbaut. In diesem Kapitel geht es darum, diese LEDs zum Leuchte zu bringen.</p>
</div>
<div class="sect2">
<h3 id="_allgemeines">4.1. Allgemeines</h3>
<div class="paragraph">
<p>Auf dem Board gibt es eine ganze Reihe von LEDs, die man programmieren kann. Da ist zunächst eine blaue Standard Arduino LED, die wie bei anderen Arduino Boards auf dem Pin 13 anzusprechen ist. Dann sind da noch 2 LEDs beim Kommunikationsmodul vorhanden, die primär Kommunikation über die serielle Schnittstelle (Bluetooth/USB) anzeigen. Dazu gibt es noch den 12er RGB LED Ring, bei dem man alle 12 LED unterschiedlich bunt einfärben kann und damit ein vielseitiges Anzeigegerät für Roboterzustände hat.</p>
</div>
<div class="paragraph">
<p>Dann gibt es noch eine grüne "On"-Status-LED (nicht programmierbar, hart verdrahtet), 2 rote LEDs direkt unter dem RGB-Ring (auch nicht programmierbar) und die blaue, ryhtmisch blinkende LED oberhalb des Reset-Tasters (auch nicht programmierbar).</p>
</div>
</div>
<div class="sect2">
<h3 id="_standard_built_in_led">4.2. Standard built-in LED</h3>
<div class="imageblock text-left">
<div class="content">
<img src="../images/auriga-Builtin-LED.gif" alt="auriga Builtin LED">
</div>
<div class="title">Abbildung 6. Eingebaute Standard-LED auf dem Board</div>
</div>
<div class="paragraph">
<p>Diese LED wird wie bei allen Arduino-Boards programmiert - man kann das Standard-Blink-Beispielprogramm nehmen:</p>
</div>
<div class="sect3">
<h4 id="_beispielprogramm">4.2.1. Beispielprogramm</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Eingebaute LED auf dem Arduino-Board blinken lassen</span>
<span class="c1">// Dies ist quasi das Standard-Test-Programm für die meisten Arduino-Boards</span>

<span class="kt">int</span> <span class="n">BlueLed</span> <span class="o">=</span> <span class="n">LED_BUILTIN</span><span class="p">;</span> <span class="c1">// Pin 13</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pinMode</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// lang an</span>
  <span class="n">digitalWrite</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
  <span class="n">delay</span> <span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
  <span class="c1">// kurz aus</span>
  <span class="n">digitalWrite</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
  <span class="n">delay</span> <span class="p">(</span><span class="mi">250</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die LED 13 ist an einen PWM-fähigen Pin angeschlossen, daher kann man die LED auch via PWM langsam ein- und ausblenden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Eingebaute LED auf dem Arduino-Board ein- und ausblenden</span>

<span class="kt">int</span> <span class="n">BlueLed</span> <span class="o">=</span> <span class="n">LED_BUILTIN</span><span class="p">;</span> <span class="c1">// Pin 13</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pinMode</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">25</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">analogWrite</span><span class="p">(</span><span class="n">BlueLed</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">delay</span> <span class="p">(</span><span class="mi">40</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">25</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">analogWrite</span><span class="p">(</span><span class="n">BlueLed</span><span class="p">,</span> <span class="p">(</span><span class="mi">25</span><span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">delay</span> <span class="p">(</span><span class="mi">40</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_onboard_leds_kommunikationsmodul">4.3. OnBoard LEDs (Kommunikationsmodul)</h3>
<div class="imageblock text-left">
<div class="content">
<img src="../images/comm-red-blue-LEDs.gif" alt="comm red blue LEDs">
</div>
<div class="title">Abbildung 7. Rote und blaue Kommunikations-Modul-LEDs</div>
</div>
<div class="paragraph">
<p>Es gibt zwei weitere LEDs auf dem Auriga Board, die zwei kleinen roten und blauen LEDs in der Nähe des USB Anschlusses. Diese werden in der Makeblock Bibliothek nicht verwendet, auch nicht in der Firmware. Man kann diese aber mit den Arduino-Standardpins ansprechen, wenn man denn erstmal weiß, an welchen Pins diese LEDs angeklemmt sind.</p>
</div>
<div class="paragraph">
<p>Daher schaut man zuerst mal in den Schaltplan <a href="downloads/MeAuriga_Schaltplan.pdf">MeAuriga_Schaltplan.pdf</a>.
Die zwei LEDs sind im Abschnitt <em>程序更新&amp;无线遥控 (dt. Programmaktualisierung und drahtlose Fernbedienung)</em> aufgeführt:</p>
</div>
<div class="imageblock text-left">
<div class="content">
<img src="../images/Schaltplanauszug_OnBoard_LEDs.png" alt="Schaltplanauszug OnBoard LEDs">
</div>
<div class="title">Abbildung 8. Auszug Schaltplan OnBoard LEDs</div>
</div>
<div class="paragraph">
<p>Diese LEDs sind mit den Pins D0/RX0 und D1/TX0 des MEGA2560 Mikrocontrollers verbunden. Diese LEDs werden hauptsächlich dafür benutzt, die Kommunikation über diese Ports anzuzeigen.
Die Anoden der LEDs sind mit +5 Volt verbunden. Also <strong>leuchten</strong> sie, wenn der jeweilige Pin (Kathodenseite) auf <strong>GND gezogen wird (LOW)</strong>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die LEDs sind auch mit dem BLE (Bluetooth Low Energy) und UART Modulen (Universal Asynchronous Receiver/Transmitter) verbunden. Wenn man die LEDs direkt ansteuert, stört das diese Module. Wahrscheinlich ist das auch der Grund, warum die beiden LEDs in der Dokumentation und in der Bibliothek nicht aufgeführt sind.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_beispielprogramm_2">4.3.1. Beispielprogramm</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Programm für den Arduino Mega</span>

<span class="c1">// Auf dem Auriga Board sind die LEDs an Pin 0 und 1 geklemmt und mit +5V verbunden</span>
<span class="kt">int</span> <span class="n">BlueLed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">RedLed</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pinMode</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span> <span class="n">RedLed</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">digitalWrite</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>  <span class="c1">// Blau anschalten</span>
  <span class="n">digitalWrite</span><span class="p">(</span> <span class="n">RedLed</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>  <span class="c1">// Rot ausschalten</span>
  <span class="n">delay</span> <span class="p">(</span><span class="mi">400</span><span class="p">);</span>
  <span class="n">digitalWrite</span><span class="p">(</span> <span class="n">BlueLed</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span> <span class="c1">// Blau ausschalten</span>
  <span class="n">digitalWrite</span><span class="p">(</span> <span class="n">RedLed</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>   <span class="c1">// Rot anschalten</span>
  <span class="n">delay</span> <span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_12er_rgb_led_ring">4.4. 12er RGB LED Ring</h3>
<div class="paragraph">
<p>Als Zusatzmodul für das Auriga-Board gibt es einen RGB Ring (Typ: ws12812).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/images/RGBRing.gif" alt="RGBRing">
</div>
<div class="title">Abbildung 9. Rings aus 12 RGBS</div>
</div>
<div class="paragraph">
<p>Der LED Ring wird über einen Controller angesteuert, der am PWM PIN 44 am Arduino Mega 2560 angeschlossen ist.</p>
</div>
<div class="paragraph">
<p>Die Programmierung des Controllers ist in der Klasse <code>MeRGBLed</code> implementiert, welche über die Include-Datei <code>MeRGBLed.h</code> eingebunden wird. Der RGB-Controller selbst wird über das WS2811/2812 Protokoll angesprochen, was aber die <code>MeRGBLed</code>-Klasse übernimmt.</p>
</div>
<div class="paragraph">
<p>Grundsätzlich hält die Klasse eine Datenstruktur für die RGB-Informationen jeder einzelnen RGB. Die Konfiguration der RGB kann nun durch Zugriffsfunktionen wie <code>setColorAt()</code> geändert werden. Dabei wird zunächst nur der interne Zustand des Klassenobjekts geändert. Die Ansteuerung des Controllers selbst und damit das Umschalten der LEDs erfolgt erst beim Aufruf von <code>show()</code>.</p>
</div>
<div class="paragraph">
<p>Die LED 0 (bzw. 1. LED) ist übrigends die LED auf "1 Uhr", wenn man sich das Bild oben anschaut. Die oberste LED ("12 Uhr") ist die LED 11.</p>
</div>
<div class="sect3">
<h4 id="_beispielprogramm_3">4.4.1. Beispielprogramm</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Testprogramm für den LED Ring auf dem Auriga Board.</span>

<span class="c1">// Zuerst den Header für das Auriga-Board einbinden</span>
<span class="cp">#include</span> <span class="cpf">&lt;MeAuriga.h&gt;</span><span class="cp">
</span>
<span class="c1">// Der Auriga on-board LED Ring hat 12 LEDs. Zur Vereinfachung der Lesbarkeit</span>
<span class="c1">// legen wir hier ein Define fest.</span>
<span class="cp">#define LEDNUM  12
</span>
<span class="c1">// Beim Auriga-Board steuern wird den on-board LED Ring an.</span>
<span class="c1">// Die Klasse MeRGBLed bietet die Schnittstellenfunktionen dafür.</span>
<span class="c1">// Im Constructor übergeben wir den Port 0</span>
<span class="n">MeRGBLed</span> <span class="nf">led</span><span class="p">(</span> <span class="n">PORT0</span><span class="p">,</span> <span class="n">LEDNUM</span> <span class="p">);</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// LED Ring Controller ist am PWM PIN D44 angeschlossen</span>
  <span class="n">led</span><span class="p">.</span><span class="n">setpin</span><span class="p">(</span> <span class="mi">44</span> <span class="p">);</span>
  <span class="c1">// Nach dem Setzen des Pin muss minimal kurz gewartet werden.</span>
  <span class="c1">// Wenn man den delay()-Aufruf vergisst, dann wird nach dem</span>
  <span class="c1">// led.show() Befehl die erste LED in grün angezeigt.</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="c1">// nun können wir die initalen LED-Werte (alle AUS/SCHWARZ) setzen</span>
  <span class="c1">// (Die Klasse MeRGBLed setzt anfänglich alle LEDs auf schwarz/aus, man kann</span>
  <span class="c1">//  aber auch led.setColor(0,0,0) vor dem led.show() nochmal aufrufen)</span>
  <span class="n">led</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// wir setzen nun unterschiedliche Farben in den LEDs und schalten diese dann jeweils an</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LEDNUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">// alle ausschalten</span>
    <span class="n">led</span><span class="p">.</span><span class="n">setColor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="c1">// die LED mit Index i anschalten</span>
    <span class="n">led</span><span class="p">.</span><span class="n">setColorAt</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">LEDNUM</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">20</span> <span class="p">);</span> <span class="c1">// i = 0...11</span>
    <span class="c1">// LED Einstellungen an den LED controller übertragen</span>
    <span class="c1">// (erst mit diesem Befehl ändern sich tatsächlich die Farben)</span>
    <span class="n">led</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
    <span class="n">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Grundlegende Herangehensweise ist immer:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Farbe ändern einzelner LEDs mit <code>setColorAt()</code> oder aller zusammen mit <code>setColor()</code></p>
</li>
<li>
<p>dann die Farben an den Controller und damit an die LED übertragen mit <code>show()</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_die_wichtigsten_funktionen_der_mergbled_klasse">4.4.2. Die wichtigsten Funktionen der MeRGBLed Klasse</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Alle RGB mit der gleichen Farbe setzen</span>
<span class="kt">bool</span> <span class="n">MeRGBLed</span><span class="o">::</span><span class="n">setColor</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">red</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">green</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">blue</span><span class="p">);</span>
<span class="c1">// Alle RGB (index=0) setzen, oder einzelne (1-basierte Indizierung; index = 1...LEDNUM)</span>
<span class="kt">bool</span> <span class="n">MeRGBLed</span><span class="o">::</span><span class="n">setColor</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">red</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">green</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">blue</span><span class="p">);</span>
<span class="c1">// Einzelne LED setzen (index = 0...LEDNUM-1); 0-basierte Indizierung der LED</span>
<span class="kt">bool</span> <span class="n">MeRGBLed</span><span class="o">::</span><span class="n">setColorAt</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">red</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">green</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">blue</span><span class="p">);</span>
<span class="c1">// Gesetzte Farben an den Controller und damit an die LED übertragen (500 µs Wartezeit bei jedem Aufruf)</span>
<span class="kt">bool</span> <span class="n">MeRGBLed</span><span class="o">::</span><span class="n">show</span><span class="p">();</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_programmierideen">4.4.3. Programmierideen</h4>
<div class="paragraph">
<p>Den RGB-Ring kann man prima für verschiedene Sachen nutzen, bspw.:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>zur Anzeige von Sensordaten, bspw. den Abstand beim Entfernungssensor</p>
</li>
<li>
<p>Kompassrichtung anzeigen oder Fahrrichtung</p>
</li>
<li>
<p>die verstrichenen Sekunden oder den Zeitverlauf anzeigen</p>
</li>
<li>
<p>oder einfach nur eine coole Knight-Raider Animation bauen</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_onboard_sensoren_licht_schall_temperature_gyroscop">5. OnBoard Sensoren (Licht, Schall, Temperature, Gyroscop)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hier geht es um das Auslesen der verschiedenen OnBoard-Sensoren auf dem Auriga-Board. Auf dem Auriga Board sind 4 Sensortypen platziert:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Schall/Lautstärke</p>
</li>
<li>
<p>Licht/Helligkeit (2 Mal, links und rechts)</p>
</li>
<li>
<p>Temperatur</p>
</li>
<li>
<p>Gyroscop/Neigungssensor</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Nachfolgend wird gezeigt, wie diese Sensoren einzeln auszulesen sind, und welche Genauigkeiten/Wertebereiche zu erwarten sind.</p>
</div>
<div class="sect2">
<h3 id="_lautstärkeschall">5.1. Lautstärke/Schall</h3>
<div class="paragraph">
<p>Der Sound-Sensor auf dem Auriga-Board wird über die Klasse <code>MeSoundSensor</code> (Include-Datei nur <code>MeAuriga.h</code>)
ausgelesen.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Im Gegensatz zu anderen MakeBlock Bausätzen (mBot etc.) ist der Sound-Sensor auf dem Auriga-Boardan Port 14 angeschlossen (siehe Variable <code>mePort</code> in der Datei <code>MeAuriga.h</code> und Erklärung dazu in <a href="#sec::basics">[sec::basics]</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die Klasse hat nur eine sinnvolle Memberfunction: <code>strength()</code>, was die Lautstärke im Bereich 140 bis ~600 ausgibt.</p>
</div>
<div class="sect3">
<h4 id="_beispielprogramm_4">5.1.1. Beispielprogramm</h4>
<div class="paragraph">
<p>Liest kontinuierlich die Lautstärke aus und übergibt diese via serieller Verbindung an den PC und kann dort bspw. mit dem Serial Plotter der Arduino-IDE angezeigt werden.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Testprogramm für den Sound-Sensor am Auriga-Board.</span>
<span class="c1">//</span>
<span class="c1">// ACHTUNG: beim Auriga ist der Sound-Sensor am Port 14 angeschlossen.</span>
<span class="cp">#include</span> <span class="cpf">&lt;MeAuriga.h&gt;</span><span class="cp">
</span>
<span class="n">MeSoundSensor</span> <span class="nf">soundSensor</span><span class="p">(</span><span class="n">PORT_14</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"value:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">soundSensor</span><span class="p">.</span><span class="n">strength</span><span class="p">()</span> <span class="p">);</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/auriga_soundsensor.png" alt="auriga soundsensor">
</div>
<div class="title">Abbildung 10. Im SerialPlotter sieht man die erfassten Werte, als ich mehrfach laut direkt über dem Auriga-Board geklatscht habe. In sehr leiser Umgebung rauscht das Signal bei ca. 130&#8230;&#8203;140.</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lichthelligkeit">5.2. Licht/Helligkeit</h3>
<div class="paragraph">
<p>Es gibt zwei Helligkeitssensoren auf dem Auriga Board:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>neben Port 2, wird über PORT_11 angesteuert</p>
</li>
<li>
<p>neben Port 9, wird über PORT_12 angesteuert</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Im Gegensatz zu anderen MakeBlock Bausätzen (mBot etc.) sind die Lichtsensoren auf dem Auriga-Board
an den Ports 11 und 12 angeschlossen (siehe Variable <code>mePort</code> in der Datei <code>MeAuriga.h</code> und Erklärung dazu in <a href="#sec::basics">[sec::basics]</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die Klasse <code>MeLightSensor</code> liest die Helligkeitswerte aus (im Bereich 0..1000) (Memberfunktion <code>read()</code>).</p>
</div>
<div class="sect3">
<h4 id="_beispielprogramm_5">5.2.1. Beispielprogramm</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Test für die Lichtsensoren</span>
<span class="cp">#include</span> <span class="cpf">&lt;MeAuriga.h&gt;</span><span class="cp">
</span>
<span class="n">MeLightSensor</span> <span class="nf">lightSensorRight</span><span class="p">(</span><span class="n">PORT_11</span><span class="p">);</span> <span class="c1">// Der Sensor neben Port 2</span>
<span class="n">MeLightSensor</span> <span class="nf">lightSensorLeft</span><span class="p">(</span><span class="n">PORT_12</span><span class="p">);</span>  <span class="c1">// Der Sensor neben Port 9</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Lichtsensoren auslesen</span>
  <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">lightSensorRight</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">lightSensorLeft</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>

  <span class="c1">// Werte via serieller Verbindung an PC senden</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"min:0,max:1000,"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"left:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",right:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
  <span class="c1">// alle 50 ms</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/auriga_lightsensors.png" alt="auriga lightsensors">
</div>
<div class="title">Abbildung 11. Bei direkten Anleuchten mit einer Fahrradlampe wurde der Wert 1000 ausgegeben. In sehr dunklen Räumen (nur der Monitor in 30 cm Entfernung ist an), zeigt der Sensor Werte zwischen 1-3. Im Beispiel oben habe ich wechselseitig den einen und dann den anderen Sensor mit der Hand abgedeckt.</div>
</div>
<div class="paragraph">
<p><em>Interessant:</em> bei moderatem Licht von Energiesparlampen zeigt der Sensor (wellenförmige schwankende) Werte zwischen 55 und 140 an.</p>
</div>
<div class="paragraph">
<p><em>Auch interessant:</em> Wenn man den Ranger seitlich ans Fenster stellt, so werden leicht unterschiedliche Helligkeitswerte angezeigt. Eine Drehung um 180° führt jedoch nicht zum Vertauschen der Helligkeitswerte beider Sensoren, wie man das vielleicht erwarten würde. Ein Regeln der Ausrichtung des Ranges basierend auf seitlich einfallendem Licht scheint eher schwierig zu sein (selber ausprobieren!).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_temperatur">5.3. Temperatur</h3>
<div class="paragraph">
<p>Auf dem Board ist ein DS18B20 Temperatursensor verbunden. Dieser wird über das Wire-Protokoll am Port 13 abgefragt. Die entsprechende Implementierung steckt in der Klasse <code>MeOnBoardTemp</code> mit der Member-Funktion <code>readValue()</code> (bzw. <code>readAnalog()</code> für den Rohwert).</p>
</div>
<div class="sect3">
<h4 id="_beispielprogramm_6">5.3.1. Beispielprogramm</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Test für den Temperatursensor</span>
<span class="cp">#include</span> <span class="cpf">&lt;MeAuriga.h&gt;</span><span class="cp">
</span>
<span class="c1">// Der OnBoard-Temperatursensor wird über Port 13 angesprochen</span>
<span class="n">MeOnBoardTemp</span> <span class="nf">tempSensor</span><span class="p">(</span><span class="n">PORT_13</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Analogwert:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">tempSensor</span><span class="p">.</span><span class="n">readAnalog</span><span class="p">());</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",Temperaturwert:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">tempSensor</span><span class="p">.</span><span class="n">readValue</span><span class="p">());</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/auriga_temperatursensor.png" alt="auriga temperatursensor">
</div>
<div class="title">Abbildung 12. Vom Sensor gelieferten Temperaturverlauf, wenn man den Arduino nach längerer Zeit (6h) erstmalig anschaltet. Ausgehend von der Raumtemperatur (ca. 22°) erwärmt sich das Board und der Sensor in wenigen Minuten auf über 25°C, wenn man noch ein paar LEDs anmacht, oder dem Mikroprozessor ordentlich was zu tun gibt, geht die Temperatur rauf auf knapp 30°C.</div>
</div>
<div class="paragraph">
<p><em>Interessant:</em> Der Temperatursensor wird maßgeblich durch die Energieabgabe von LEDs und des Prozessors allgemein beeinflusst. Die Umgebungstemperatur lässt sich damit nur sehr ungenau messen, da die Wärmezirkulation zum Sensor durch das Plastikgehäuse behindert ist.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gyroskop">5.4. Gyroskop</h3>
<div class="paragraph">
<p>Das Auriga-Board hat einen Neigungssensor verbaut. Dieser liefert für die 3 Achsen x,y,z jeweils Neigungswerte/Ausrichtungswerte und dazu die Beschleunigungen auf den 3 Achsen.</p>
</div>
<div class="paragraph">
<p>Die Achsenzuordnung ist dabei wie folgt:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>X-Achse : Kippen um die Querachse (<em>der Anstieg beim Fahren auf einen Hügel</em>): -90° (nach unten)&#8230;&#8203;90° (nach oben)</p>
</li>
<li>
<p>Y-Achse : Kippen um die Längsachse; -90° (nach rechts gedreht) &#8230;&#8203;90° (nach links gedreht)</p>
</li>
<li>
<p>Z-Achse :  N, O, S, W Ausrichtung; 0° = der USB-Port zeigt nach Norden; -180°/180° = der USB-Port zeigt nach Süden; -90° = der USB-Port zeigt nach Westen</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Entsprechend ist die X-Beschleunigung die Beschleunigung vorwärts und Y-Beschleunigung die Drehbeschleunigung. Interessant ist die Z-Beschleunigung (Querbeschleunigung) beim schnellen Kurvenfahren.</p>
</div>
<div class="paragraph">
<p>Zum Auslesen des Neigungssensors/Gyroskops verwendet man die Klasse <code>MeGyro</code> wie im nachfolgendem Beispiel gezeigt.</p>
</div>
<div class="sect3">
<h4 id="_beispielprogramm_7">5.4.1. Beispielprogramm</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Testprogramm für den Neigungssensor</span>
<span class="cp">#include</span> <span class="cpf">&lt;MeAuriga.h&gt;</span><span class="cp">
</span>
<span class="n">MeGyro</span> <span class="nf">gyro</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GYRO_DEFAULT_ADDRESS</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>

  <span class="c1">// Klasse initialisieren</span>
  <span class="n">gyro</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Aktualisiere Zustand des gyro-Objects (liest Sensoren aus und berechnet Winkel/Beschleunigungen)</span>
  <span class="c1">// Alternativ kann man auch fast_update() verwenden</span>
  <span class="n">gyro</span><span class="p">.</span><span class="n">update</span><span class="p">();</span>

  <span class="c1">// greife auf die Sensordaten zu</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Angle-X:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">gyro</span><span class="p">.</span><span class="n">getAngleX</span><span class="p">());</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",Angle-Y:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">gyro</span><span class="p">.</span><span class="n">getAngleY</span><span class="p">());</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",Angle-Z:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">gyro</span><span class="p">.</span><span class="n">getAngleZ</span><span class="p">());</span>

  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",Gyro-X:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">gyro</span><span class="p">.</span><span class="n">getGyroX</span><span class="p">());</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",Gyro-Y:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">gyro</span><span class="p">.</span><span class="n">getGyroY</span><span class="p">());</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",Gyro-Z:"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">gyro</span><span class="p">.</span><span class="n">getGyroZ</span><span class="p">());</span>

  <span class="n">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_töne_mit_dem_passiven_buzzer_auf_dem_board">6. Töne mit dem passiven Buzzer auf dem Board</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hier steuern wir den passiven Buzzer auf dem Board an.</p>
</div>
<div class="sect2">
<h3 id="_allgemeines_2">6.1. Allgemeines</h3>
<div class="paragraph">
<p>Auf dem Auriga-Board ist ein passiver Buzzer verbaut, welcher an einen PWM-Pin angeschlossen ist. Der Buzzer ist an Pin 45 angeschlossen.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/auriga_buzzer.png" alt="auriga buzzer">
</div>
</div>
<div class="paragraph">
<p>Beim Blick in die Include-Datei <code>MeAuriga.h</code> fällt einem am Schluss der Datei folgende Quelltext auf:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#define   pinMode(45,OUTPUT),digitalWrite(45, HIGH)
#define buzzerOff() pinMode(45,OUTPUT),digitalWrite(45, LOW)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Hier wird also beim Einschalten der Pegel auf HIGH gezogen und beim Ausschalten der Pegel wieder auf LOW. Das ist allerdings Code, der für einen aktiven Buzzer gedacht ist, und wahrscheinlich vergessen wurde, zu entfernen.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Achtung"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Für den MakeBlock ranger sind die Funktionen <code>buzzerOn()</code> und <code>buzzerOff()</code> <span class="underline">nicht</span> zu verwenden.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Um den passiven Buzzer anzusteuern, verwendet man <code>tone()</code> und zum Ausschalten <code>noTone()</code>. Hier ist ein Beispiel, für die direkte Ansteuerung des Pins.</p>
</div>
<div class="sect3">
<h4 id="_beispielprogramm_8">6.1.1. Beispielprogramm</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#define BUZZER_PIN 45
</span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span>  <span class="p">{</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span>  <span class="p">{</span>
  <span class="n">tone</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">,</span> <span class="mi">131</span><span class="p">);</span>   <span class="c1">// c</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">1200</span><span class="p">);</span>

  <span class="n">tone</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">,</span> <span class="mi">165</span><span class="p">);</span>   <span class="c1">// e</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">400</span><span class="p">);</span>

  <span class="n">tone</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">,</span> <span class="mi">196</span><span class="p">);</span>   <span class="c1">// g</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">1800</span><span class="p">);</span>

  <span class="n">noTone</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">);</span>     <span class="c1">// aus</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">4000</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Hier ist noch ein Programm, bei dem aus dem einfachen Buzzer etwas interessantere Geräusche raus kommen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#define BUZZER_PIN 45
</span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span>  <span class="p">{</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span>  <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">35</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">freq</span> <span class="o">=</span> <span class="mi">80</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mi">10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">terz</span> <span class="o">=</span> <span class="n">freq</span><span class="o">*</span><span class="mf">6.0</span><span class="o">/</span><span class="mi">5</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">tone</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>
      <span class="n">delay</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
      <span class="n">tone</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">,</span> <span class="n">terz</span><span class="p">);</span>
      <span class="n">delay</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">35</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">freq</span> <span class="o">=</span> <span class="mi">80</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mi">10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">terz</span> <span class="o">=</span> <span class="n">freq</span><span class="o">*</span><span class="mf">6.0</span><span class="o">/</span><span class="mi">5</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">tone</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">,</span> <span class="n">freq</span><span class="p">);</span>
      <span class="n">delay</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
      <span class="n">tone</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">,</span> <span class="n">terz</span><span class="p">);</span>
      <span class="n">delay</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Eine Liste von Frequenzen für die ersten 6 Oktaven findet man im Arduino-Beispiel: <code>02. Digital-&gt;toneMelody</code> und der dort enthaltenen Datei <code>pitches.h</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_verwendung_der_makeblock_klasse_mebuzzer">6.2. Verwendung der Makeblock Klasse MeBuzzer</h3>
<div class="paragraph">
<p>In der Makeblock-Bibliothek gibt es noch die Klasse <code>MeBuzzer</code>. Diese kapselt den Zugriff, macht die Ansteuerung des Buzzers aber nicht wirklich einfacher.
Man kann mittels der Member-Funktion <code>MeBuzzer::tone(frequenz, dauer in ms)</code> einen Ton ausgeben. Diese Funktion implementiert einen Software-PWM (d.h. in dieser Funktion wird der angegebene Buzzer-Pin sehr häufig an und aus geschaltet, wobei das Verhältnis der an/aus-Zeiten die Tonhöhe definiert).
Somit kann man auch externe Buzzer anschließen und dabei Ports mit digitalen Pins (keinen analogen Pins) nutzen.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Für die Verwendung des OnBoard-Buzzers sollte man die <code>MeBuzzer</code>-Klasse <em>nicht</em> benutzen, sondern stattdessen wie im Beispiel oben via <code>tone()</code>
die Frequenz einstellen. Das hat auch den Vorteil, dass man ohne Wartezeiten parallel zum Melodie abspielen noch Sensoren auslesen und andere Dinge steuern kann.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_beispielprogramm_9">6.2.1. Beispielprogramm</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Beispielprogramm für die Verwendung der MeBuzzer-Klasse</span>
<span class="c1">// Diese Variante ist aber NICHT EMPFOHLEN (siehe Text)</span>
<span class="cp">#include</span> <span class="cpf">&lt;MeAuriga.h&gt;</span><span class="cp">
</span>
<span class="cp">#define BUZZER_PIN 45
</span>
<span class="n">MeBuzzer</span> <span class="n">buzzer</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span>  <span class="p">{</span>
  <span class="n">buzzer</span><span class="p">.</span><span class="n">setpin</span><span class="p">(</span><span class="n">BUZZER_PIN</span><span class="p">);</span>
  <span class="n">buzzer</span><span class="p">.</span><span class="n">noTone</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span>  <span class="p">{</span>
  <span class="n">buzzer</span><span class="p">.</span><span class="n">tone</span><span class="p">(</span><span class="mi">262</span><span class="p">,</span> <span class="mi">250</span><span class="p">);</span>   <span class="c1">//NOTE_C4</span>
  <span class="n">buzzer</span><span class="p">.</span><span class="n">tone</span><span class="p">(</span><span class="mi">294</span><span class="p">,</span> <span class="mi">250</span><span class="p">);</span>   <span class="c1">//NOTE_D4</span>
  <span class="n">buzzer</span><span class="p">.</span><span class="n">tone</span><span class="p">(</span><span class="mi">330</span><span class="p">,</span> <span class="mi">250</span><span class="p">);</span>   <span class="c1">//NOTE_E4</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>

  <span class="n">buzzer</span><span class="p">.</span><span class="n">tone</span><span class="p">(</span><span class="mi">587</span><span class="p">,</span> <span class="mi">250</span><span class="p">);</span>   <span class="c1">//NOTE_D5</span>
  <span class="n">buzzer</span><span class="p">.</span><span class="n">tone</span><span class="p">(</span><span class="mi">659</span><span class="p">,</span> <span class="mi">250</span><span class="p">);</span>   <span class="c1">//NOTE_E5</span>
  <span class="n">buzzer</span><span class="p">.</span><span class="n">tone</span><span class="p">(</span><span class="mi">523</span><span class="p">,</span> <span class="mi">250</span><span class="p">);</span>   <span class="c1">//NOTE_C5</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_motorsteuerung">7. Motorsteuerung</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Jetzt wird endlich mal was bewegt. In diesem Teil geht es um die Programmierung der Motoren.</p>
</div>
<div class="sect2">
<h3 id="_allgemeines_3">7.1. Allgemeines</h3>
<div class="paragraph">
<p>Am Auriga-Board gibt es zwei Motorports. Jeder der Motoren kann über einen PWM Pin (für die Geschwindigkeit) und zwei Richtungspins angesteuert werden.
Die Ansteuerung kann einmal direkt über die Arduino-Pins erfolgen oder unter Verwendung der Makeblock Bibliothek.</p>
</div>
<div class="paragraph">
<p>Grundsätzlich bewegen sich die Motoren nur, wenn die Spannungsversorgung über die Batterien erfolt. Das ist auch ganz praktisch, da man so den Robotor angesteckt an den Computer programmieren kann, ohne Angst zu haben, dass er vom Tisch rollt.</p>
</div>
</div>
<div class="sect2">
<h3 id="_direkte_ansteuerung_über_pwm_und_digitale_pins">7.2. Direkte Ansteuerung über PWM und digitale Pins</h3>
<div class="paragraph">
<p>Aus dem Schaltplan kann man die Bezeichnung der digitalen Pins (D46-D49) und die PWM Pins (D10, D11) entnehmen:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/auriga_motorports.png" alt="auriga motorports">
</div>
<div class="title">Abbildung 13. Motor-Ports an der Auriga-Platine</div>
</div>
<div class="paragraph">
<p>Die Pins werden nun wie folgt angesprochen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>PWMA und PWMB erhalten Drehgeschwindigkeiten im Bereich von 0..255</p>
</li>
<li>
<p>DIRA1 und DIRA2 regeln die Richtung des Motors A (links) und müssen jeweils entgegengesetzt geschaltet sein</p>
</li>
<li>
<p>DIRB1 und DIRB2 regeln die Richtung des Motors B (rechts) und müssen jeweils entgegengesetzt geschaltet sein</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_beispielprogramm_direkte_ansteuerung">7.2.1. Beispielprogramm - Direkte Ansteuerung</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Testprogramm für die Ansteuerung der DC-Motoren mittels Arduino Pin Bibliothek</span>

<span class="cp">#define PWMA  11 // Motor A/Links
#define DIRA1 49
#define DIRA2 48
#define PWMB  10 // Motor B/Rights
#define DIRB1 47
#define DIRB2 46
</span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// PWM und Richtungspins setzen</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">PWMA</span><span class="p">,</span>  <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">DIRA1</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">DIRA2</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">PWMB</span><span class="p">,</span>  <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">DIRB1</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">DIRB1</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>

  <span class="c1">// kurze Wartephase zur Initialisierung</span>
  <span class="n">delay</span> <span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">leftMotorSpeed</span><span class="p">(</span><span class="kt">int</span> <span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">analogWrite</span> <span class="p">(</span><span class="n">PWMA</span><span class="p">,</span>  <span class="n">speed</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRA1</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRA2</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">analogWrite</span> <span class="p">(</span><span class="n">PWMA</span><span class="p">,</span>  <span class="o">-</span><span class="n">speed</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRA1</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRA2</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">rightMotorSpeed</span><span class="p">(</span><span class="kt">int</span> <span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">analogWrite</span> <span class="p">(</span><span class="n">PWMB</span><span class="p">,</span>  <span class="n">speed</span><span class="p">);</span>
      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRB1</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
      <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRB2</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">analogWrite</span> <span class="p">(</span><span class="n">PWMB</span><span class="p">,</span>  <span class="o">-</span><span class="n">speed</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRB1</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">DIRB2</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// Maximalgeschwindigkeit, falls die Akkus langsam schlapp machen, sollte man hier kleinere Zahlenwerte nehmen</span>
<span class="kt">int</span> <span class="n">maxSpeed</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">upward</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// Steuerungsprogramm:</span>
  <span class="c1">// - Vorwärtsfahren und Geschwindigkeit in jeder Schleife erhöhen bis Maximalgeschwindikeit erreicht ist</span>
  <span class="c1">// - dann langsamer werden und schließlich Rückwärtsfahren bis maximale Rückwärtsgeschwindigkeit erreicht ist</span>
  <span class="c1">// - dann wieder umschalten auf vorwärts fahren</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">upward</span><span class="p">)</span>
    <span class="n">speed</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">speed</span> <span class="o">-=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&gt;</span> <span class="n">maxSpeed</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">upward</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">speed</span> <span class="o">=</span> <span class="n">maxSpeed</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">maxSpeed</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">upward</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">speed</span> <span class="o">=</span> <span class="o">-</span><span class="n">maxSpeed</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Motorgeschwindigkeiten anpassen</span>
  <span class="n">leftMotorSpeed</span><span class="p">(</span><span class="n">speed</span><span class="p">);</span>
  <span class="n">rightMotorSpeed</span><span class="p">(</span><span class="n">speed</span><span class="p">);</span>

  <span class="n">delay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Hier fährt der Roboter einfach nur vor und zurück und beschleunigt/bremst dabei.</p>
</div>
<div class="paragraph">
<p>Wenn man den Robotor mit Maximalgeschwindigkeit fahren lässt, so schafft er bei vollen Batterien noch 0,56 m/s bzw. 2 km/h.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ansteuerung_über_encoder_klasse_der_bibliothek">7.3. Ansteuerung über Encoder-Klasse der Bibliothek</h3>
<div class="paragraph">
<p>Die MakeBlock-Bibliothek bietet zahlreiche Klassen für die Programmierung von Encodern. Für die mitgelieferten DC-Motoren wird die Klasse <code>MeEncoderOnBoard</code> verwendet. Diese übernimmt, wie der Name schon sagt, die Programmierung der auf dem Board befindlichen Motorsteuerung.</p>
</div>
<div class="paragraph">
<p>Diese Art der Programmierung hat den Vorteil, dass man die konkrete Geschwindigkeit und damit auch Position abfragen kann und somit - zumindest in Theorie - den Roboter sehr präzise bewegen kann. Allerdings ist die Programmierung auch etwas komplexer: man muss nämlich die Arduino-PWM Frequenzen umprogrammieren.</p>
</div>
<div class="paragraph">
<p>Die Motoren liefern Bewegungsimpulse, die man zählen kann, um so Geschwindigkeit und Entfernung zu bestimmen. Damit man das präzise machen kann, ohne dass anderen Aufgaben im Mikroprozessor die Messung beeinträchtigen, verwendet man Interruptfunktionen. Dazu registriert man für jeden Motor eine Interruptfunktion, die immer dann aufgerufen wird, wenn am entsprechenden Pin ein RISING Signal anliegt (also der Eingangspin von LOW auf HIGH wechselt). In der Interruptfuktion wird dann ein Zähler hochgezählt, der dann für die Berechnung der Momentangeschwindigkeit und Bewegung verwendet wird. Die Berechnung selbst ist in der Klasse <code>MeEncoderOnBoard</code> gekapselt.</p>
</div>
<div class="sect3">
<h4 id="_beispielprogramm_ansteuerung_mittels_bibliotheksfunktion">7.3.1. Beispielprogramm - Ansteuerung mittels Bibliotheksfunktion</h4>
<div class="paragraph">
<p>Im Folgenden Testbeispiel kann man den Robotor begrenzt steuern:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Nach Start des Programms den SerialMonitor der Arduino-IDE aufrufen</p>
</li>
<li>
<p>in die Zeile "Nachricht" eine Zahl 0&#8230;&#8203;6 eintippen und mit Enter abschicken</p>
</li>
<li>
<p>das Programm wertet diese Zahl aus und legt die Drehgeschwindigkeit der Motoren fest</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cm">/* Testprogramm für die Ansteuerung der DC Motoren via Makeblock Bibliothek */</span>
<span class="cp">#include</span> <span class="cpf">&lt;MeAuriga.h&gt;</span><span class="cp">
</span>
<span class="n">MeEncoderOnBoard</span> <span class="nf">Encoder_1</span><span class="p">(</span><span class="n">SLOT1</span><span class="p">);</span>
<span class="n">MeEncoderOnBoard</span> <span class="nf">Encoder_2</span><span class="p">(</span><span class="n">SLOT2</span><span class="p">);</span>

<span class="c1">// Für präzise Messung der Geschwindigkeit (und damit Position) der Motoren</span>
<span class="c1">// werden die Pulse via Interruptfunktionen hoch/runtergezählt.</span>
<span class="c1">// Jedes Mal, wenn der Interrupt-Pin eines Encoders von LOW auf HIGH wechselt (RISING),</span>
<span class="c1">// wird die jeweilige isr_process_encoderX() Funktion aufgerufen und zählt einen</span>
<span class="c1">// Pulse hoch.</span>

<span class="c1">// Interruptfunktion für Encoder 1</span>
<span class="kt">void</span> <span class="nf">isr_process_encoder1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">digitalRead</span><span class="p">(</span><span class="n">Encoder_1</span><span class="p">.</span><span class="n">getPortB</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">Encoder_1</span><span class="p">.</span><span class="n">pulsePosMinus</span><span class="p">();</span>
  <span class="k">else</span>
    <span class="n">Encoder_1</span><span class="p">.</span><span class="n">pulsePosPlus</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Interruptfunktion für Encoder 2</span>
<span class="kt">void</span> <span class="n">isr_process_encoder2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">digitalRead</span><span class="p">(</span><span class="n">Encoder_2</span><span class="p">.</span><span class="n">getPortB</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">Encoder_2</span><span class="p">.</span><span class="n">pulsePosMinus</span><span class="p">();</span>
  <span class="k">else</span>
    <span class="n">Encoder_2</span><span class="p">.</span><span class="n">pulsePosPlus</span><span class="p">();</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="n">lastOutputMillis</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Festlegen der Interruptfunktionen für das Messen/Zählen der Bewegung</span>
  <span class="n">attachInterrupt</span><span class="p">(</span><span class="n">Encoder_1</span><span class="p">.</span><span class="n">getIntNum</span><span class="p">(),</span> <span class="n">isr_process_encoder1</span><span class="p">,</span> <span class="n">RISING</span><span class="p">);</span>
  <span class="n">attachInterrupt</span><span class="p">(</span><span class="n">Encoder_2</span><span class="p">.</span><span class="n">getIntNum</span><span class="p">(),</span> <span class="n">isr_process_encoder2</span><span class="p">,</span> <span class="n">RISING</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>

  <span class="c1">// Interne Timer der PWM auf 8KHz programmieren</span>
  <span class="n">TCCR1A</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM10</span><span class="p">);</span>
  <span class="n">TCCR1B</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">CS11</span><span class="p">)</span> <span class="o">|</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM12</span><span class="p">);</span>

  <span class="n">TCCR2A</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM21</span><span class="p">)</span> <span class="o">|</span> <span class="n">_BV</span><span class="p">(</span><span class="n">WGM20</span><span class="p">);</span>
  <span class="n">TCCR2B</span> <span class="o">=</span> <span class="n">_BV</span><span class="p">(</span><span class="n">CS21</span><span class="p">);</span>

  <span class="c1">// Variable für gelegentliche Ausgaben auf die serielle Schnittstelle</span>
  <span class="n">lastOutputMillis</span> <span class="o">=</span> <span class="n">millis</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// von der seriellen Schnittstelle lesen</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Serial</span><span class="p">.</span><span class="n">available</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Zeichen 0...6 werden gelesen</span>
    <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Serial</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="sc">'0'</span><span class="p">:</span>
        <span class="n">Encoder_1</span><span class="p">.</span><span class="n">setTarPWM</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">Encoder_2</span><span class="p">.</span><span class="n">setTarPWM</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="sc">'1'</span><span class="p">:</span>
        <span class="n">Encoder_1</span><span class="p">.</span><span class="n">setTarPWM</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
        <span class="n">Encoder_2</span><span class="p">.</span><span class="n">setTarPWM</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="sc">'2'</span><span class="p">:</span>
        <span class="n">Encoder_1</span><span class="p">.</span><span class="n">setTarPWM</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
        <span class="n">Encoder_2</span><span class="p">.</span><span class="n">setTarPWM</span><span class="p">(</span><span class="o">-</span><span class="mi">200</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="sc">'3'</span><span class="p">:</span>
        <span class="n">Encoder_1</span><span class="p">.</span><span class="n">setTarPWM</span><span class="p">(</span><span class="mi">255</span><span class="p">);</span>
        <span class="n">Encoder_2</span><span class="p">.</span><span class="n">setTarPWM</span><span class="p">(</span><span class="o">-</span><span class="mi">255</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="sc">'4'</span><span class="p">:</span>
        <span class="n">Encoder_1</span><span class="p">.</span><span class="n">setTarPWM</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">);</span>
        <span class="n">Encoder_2</span><span class="p">.</span><span class="n">setTarPWM</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="sc">'5'</span><span class="p">:</span>
        <span class="n">Encoder_1</span><span class="p">.</span><span class="n">setTarPWM</span><span class="p">(</span><span class="o">-</span><span class="mi">200</span><span class="p">);</span>
        <span class="n">Encoder_2</span><span class="p">.</span><span class="n">setTarPWM</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="sc">'6'</span><span class="p">:</span>
        <span class="n">Encoder_1</span><span class="p">.</span><span class="n">setTarPWM</span><span class="p">(</span><span class="o">-</span><span class="mi">255</span><span class="p">);</span>
        <span class="n">Encoder_2</span><span class="p">.</span><span class="n">setTarPWM</span><span class="p">(</span><span class="mi">255</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
      <span class="nl">default:</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// In der loop() Funktion wird die Geschwindigkeit im Motor geregelt</span>
  <span class="n">Encoder_1</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span>
  <span class="n">Encoder_2</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span>

  <span class="c1">// alle 100 Millisekunden die Geschwindigkeit ausgeben</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">millis</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">lastOutputMillis</span> <span class="o">+</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lastOutputMillis</span> <span class="o">=</span> <span class="n">millis</span><span class="p">();</span>
    <span class="c1">// Geschwindigkeit in Umdrehungen pro Minute (rpm) auslesen und ausgeben</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Speed 1:"</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">Encoder_1</span><span class="p">.</span><span class="n">getCurrentSpeed</span><span class="p">());</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">",Speed 2:"</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">Encoder_2</span><span class="p">.</span><span class="n">getCurrentSpeed</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Es gibt verschiedene Funktionen, um die Geschwindigkeit der Motoren zu steuern. Die Klasse <code>MeEncoderOnBoard</code> hat auch Funktionen für das Fahren einer definierten Strecke oder zu einem Punkt. Dazu einfach mal in die Dokumentation der Klasse schauen.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_abschließende_bemerkungen">8. Abschließende Bemerkungen</h2>
<div class="sectionbody">

</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.0 (11.01.2025)<br>
Last updated 2025-02-16 09:09:30 +0100
</div>
</div>
</body>
</html>