:imagesdir: ./images

[[sec:basics]]
# Die Grundlagen der Auriga-Programmierung

Bevor man mit der Programmierung loslegt, hilft es, sich einen kleinen Überblick über die Möglichkeiten zu verschaffen. De Informationen in diesem Kapitel sind aber eher als Referenz zu verstehen, da die einzelnen Ports und Pins in den nachfolgenden Kapiteln für alle Komponenten nochmal einzeln eingeführt und erklärt werden.

.Auriga Board PinOut Diagramm
image::auriga_pinout.png[]

Wenn man das Board mit der Makeblock-Bibliothek programmieren will, muss man die Port-Nummern kennen. Diese sind in der Makeblock-Bibliothek in der Datei `MeAuriga.h` definiert: 
Jeder Makeblock-Port ist an 2 Arduino-Pins angeschlossen (siehe auch Erklärung dazu in <<sec:rj25>>. Diese Pins werden als _Slot1_ und _Slot2_ bezeichnet. 

.Auszug aus der Header-Datei 'MeAuriga.h'
```c++
MePort_Sig mePort[17] =
{
	{ NC, NC }, {   5,   4 }, {   3,   2 }, {   7,   6 }, {   9,   8 }, 
	{ 16, 17 }, { A10, A15 }, {  A9, A14 }, {  A8, A13 }, {  A7, A12 }, 
	//             LIGHT2        LIGHT1        TEMP          SOUND
	{ A6,A11 }, {  NC,  A2 }, {  NC,  A3 }, {  NC,  A0 }, {  NC,  A1 },
	{ NC, NC }, { NC, NC },
};

// etwas umformatiert und kommentiert
MePort_Sig mePort[17] = {
	Port 0  {  NC,  NC }   Not connected
	Port 1  {   5,   4 }   red
	Port 2  {   3,   2 }   red
	Port 3  {   7,   6 }   red
	Port 4  {   9,   8 }   red
	Port 5  {  16,  17 }   grey
	Port 6  { A10, A15 }   universal
	Port 7  {  A9, A14 }   universal 
	Port 8  {  A8, A13 }   universal
	Port 9  {  A7, A12 }   universal
	Port 10 {  A6, A11 }   universal 
	Port 11 {  NC,  A2 }   light sensor 1
	Port 12 {  NC,  A3 }   light sensor 2
	Port 13 {  NC,  A0 }   temperature sensor
	Port 14 {  NC,  A1 }   sound sensor
	Port 15 {  NC,  NC }   
	Port 16 {  NC,  NC }   
}
```

Als Beispiel: der Universal Port 6 ist an den analogen Pin 10 und Analogen Pin 15 des Arduino Mikrocontrollers angeschlossen. _NC_ steht für _Not Connected_. Ports 1 bis 10 sind RJ25 Ports (dazu mehr im Kapitel zu den RJ25 Anschlüssen).

Es sind aber nicht alle Komponenten über diese Ports/Pins (des Arduino 2560 Mega) anzusteuern:

```
Pin 44 = 12 RGB LED Ring
Pin 45 = Buzzer
Pin 13 = Blaue LED (built-in LED)
```

Die Motoren können zwar recht einfach durch die Bibliothek angesteuert werden, hier sind aber nochmal die Pins (falls man die Motoren klassisch über den Arduino ansteuern möchte, siehe Kapitel über die Motorensteuerung <<sec:motoren>>):

```
ENA A  = pin 19
ENA B  = pin 42
PWMA   = pin 11
DIR A2 = pin 49
DIR A1 = pin 48

ENB A  = pin 18
ENB B  = pin 43
PWMB   = pin 10
DIR B1 = pin 47
DIR B2 = pin 46
```


## Kleines Testbeispiel

Um das Aufspielen des Programms zu testen, kann man die eingebaute LED auf Pin 13 (wie bei jedem Arduino Board) blinken lassen. Das Programm dazu entspricht dem typischen Arduino Blink-Beispielprogramm:


.Triviales Beispielprogramm für ein Arduino-Board. Die eingebaute LED wird ein- und ausgeschaltet. Um sie von der rhythmisch blinkenden anderen blauen LED zu unterscheiden, lassen wir sie lang-kurz blinken.
```c++
// Eingebaute LED auf dem Arduino-Board blinken lassen
// Dies ist quasi das Standard-Test-Programm für die meisten Arduino-Boards

int BlueLed = LED_BUILTIN; // Pin 13

void setup() {
  pinMode( BlueLed, OUTPUT);
}

void loop() {
  // lang an
  digitalWrite( BlueLed, HIGH);
  delay (2000);
  // kurz aus
  digitalWrite( BlueLed, LOW);
  delay (500);
}
```

[NOTE]
====
Die LED ist etwas schwer zu erkennen und liegt einseitig etwas verdeckt. Sehr sinnvoll ist damit ihre Ansteuerung nicht, aber zum Testen kann man das ja mal machen.
====

.Auriga Built-in LED
image::auriga-Builtin-LED.gif[align="left"]



